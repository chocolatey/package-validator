<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lokad.Shared</name>
    </assembly>
    <members>
        <member name="T:GlobalAssemblyInfo">
            <summary>
             Assembly information class that is shared between all projects
            </summary>
        </member>
        <member name="T:Lokad.CurrencyAmount">
            <summary>
            	Decimal that also has currency type assotiated. It is used
            	for enforcing logical consistency within the billing.
            
            	We want to reduce chances of messing up by mixing different
            	currencies together.
            </summary>
        </member>
        <member name="F:Lokad.CurrencyAmount.Zero">
            <summary>
            Default empty currency amount with undefined currency type
            </summary>
        </member>
        <member name="F:Lokad.CurrencyAmount.Currency">
            <summary>Currency type</summary>
        </member>
        <member name="F:Lokad.CurrencyAmount.Value">
            <summary>
            	Value in the given currency
            </summary>
        </member>
        <member name="M:Lokad.CurrencyAmount.#ctor(Lokad.CurrencyType,System.Decimal)">
            <summary>
            	Initializes a new instance of the
            	<see cref="T:Lokad.CurrencyAmount"/>
            	struct.
            </summary>
            <param name="currency">The currency.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Lokad.CurrencyAmount.Equals(Lokad.CurrencyAmount)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">
            	An object to compare with this object.
            </param>
            <returns>
            	true if the current object is equal to the
            	<paramref name="other" />
            	parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.Equals(System.Object)">
            <summary>
            	Determines whether the specified
            	<see cref="T:System.Object"/>
            	is equal to this instance.
            </summary>
            <param name="obj">
            	The
            	<see cref="T:System.Object"/>
            	to compare with this instance.
            </param>
            <returns>
            	<c>true</c>
            	if the specified
            	<see cref="T:System.Object"/>
            	is equal to this instance; otherwise,
            	<c>false</c>
            	.
            </returns>
            <exception cref="T:System.NullReferenceException">
            	The
            	<paramref name="obj"/>
            	parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.GetHashCode">
            <summary>
            	Returns a hash code for this instance.
            </summary>
            <returns>
            	A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.ToString(System.String,System.IFormatProvider)">
            <summary>
            	Returns a
            	<see cref="T:System.String"/>
            	that represents this instance, using the 
            	provided format options to pass to the
            	<see cref="M:System.Decimal.ToString(System.String,System.IFormatProvider)"/>
            </summary>
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            <returns>
            	A
            	<see cref="T:System.String"/>
            	that represents this instance.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.ToString">
            <summary>
            	Returns a
            	<see cref="T:System.String"/>
            	that represents this instance.
            </summary>
            <returns>
            	A
            	<see cref="T:System.String"/>
            	that represents this instance.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.Round(System.Int32)">
            <summary>
            	Rounds the specified amount to the specified amount of decimals.
            </summary>
            <param name="decimals">The decimals.</param>
            <returns>rounded instance</returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.Convert(System.Func{System.Decimal,System.Decimal})">
            <summary>
            	Converts this aurrency amount by applying the specified
            	transformation function to the amount and returning new result instance.
            </summary>
            <param name="conversion">The conversion.</param>
            <returns>new result instance</returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Division(Lokad.CurrencyAmount,System.Decimal)">
            <summary>
            	Implements the operator /.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="value">The value.</param>
            <returns>
            	The result of the operator.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Multiply(Lokad.CurrencyAmount,System.Decimal)">
            <summary>
            	Implements the operator *.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="value">The value.</param>
            <returns>
            	The result of the operator.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Addition(Lokad.CurrencyAmount,System.Decimal)">
            <summary>
            	Implements the operator +.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="value">The value.</param>
            <returns>
            	The result of the operator.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Addition(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator +.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">The amount to add.</param>
            <returns>
            	The result of the operator.
            </returns>
            ///
            <exception cref="T:Lokad.CurrencyMismatchException">
            	If currency types do not match
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Subtraction(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator -.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">
            	The amount to subtract.
            </param>
            <returns>
            	The result of the operator.
            </returns>
            <exception cref="T:Lokad.CurrencyMismatchException">
            	If currency types do not match
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_GreaterThan(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator &gt;.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">
            	The amount to compare with.
            </param>
            <returns>
            	The result of the operator.
            </returns>
            <exception cref="T:Lokad.CurrencyMismatchException">
            	If currency types do not match
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_GreaterThanOrEqual(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator &gt;=.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">
            	The amount to compare with.
            </param>
            <returns>
            	The result of the operator.
            </returns>
            <exception cref="T:Lokad.CurrencyMismatchException">
            	If currency types do not match
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_LessThanOrEqual(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator &lt;=.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">
            	The amount to compare with.
            </param>
            <returns>
            	The result of the operator.
            </returns>
            <exception cref="T:Lokad.CurrencyMismatchException">
            	If currency types do not match
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_LessThan(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator &lt;.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">
            	The amount to subtract.
            </param>
            <returns>
            	The result of the operator.
            </returns>
            <exception cref="T:Lokad.CurrencyMismatchException">
            	If currency types do not match
            </exception>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Equality(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator ==.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">The amount.</param>
            <returns>
            	The result of the operator.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_Inequality(Lokad.CurrencyAmount,Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator !=.
            </summary>
            <param name="originalValue">The original value.</param>
            <param name="amount">The amount.</param>
            <returns>
            	The result of the operator.
            </returns>
        </member>
        <member name="M:Lokad.CurrencyAmount.op_UnaryNegation(Lokad.CurrencyAmount)">
            <summary>
            	Implements the operator -.
            </summary>
            <param name="originalValue">The original value.</param>
            <returns>
            	The result of the operator.
            </returns>
        </member>
        <member name="T:Lokad.CurrencyMismatchException">
            <summary>
            	Exception related to the situations when currency logic is violated.
            </summary>
            <remarks>
            	All currency conversion operations should be handled by the
            	appropriate currency manager, that will take care of fetching the
            	proper conversion rates
            </remarks>
        </member>
        <member name="M:Lokad.CurrencyMismatchException.#ctor">
            <summary>
            	Initializes a new instance of the
            	<see cref="T:Lokad.CurrencyMismatchException"/>
            	class.
            </summary>
        </member>
        <member name="M:Lokad.CurrencyMismatchException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the
            	<see cref="T:Lokad.CurrencyMismatchException"/>
            	class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Lokad.CurrencyType">
            <summary>
            	Currency types supported by the Lokad business
            </summary>
            <remarks>
            	Hardcoded for simplicity, but could be switched to string codes, if needed.
            </remarks>
        </member>
        <member name="F:Lokad.CurrencyType.None">
            <summary>
            Undefined currency
            </summary>
            <remarks>this must be default!</remarks>
        </member>
        <member name="F:Lokad.CurrencyType.Eur">
            <summary>
            EUR
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Usd">
            <summary>
            American Dollar
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Aud">
            <summary>
            Australian dollar
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Cad">
            <summary>
            Canadian dollar
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Chf">
            <summary>
            Swiss franc
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Gbp">
            <summary>
            Pound sterling
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Jpy">
            <summary>
            Japanese yen
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Rub">
            <summary>
            Russian ruble
            </summary>
        </member>
        <member name="F:Lokad.CurrencyType.Mxn">
            <summary>
            Mexican Peso
            </summary>
        </member>
        <member name="T:Lokad.ExtendDecimal">
            <summary>
            	Extensions around
            	<see cref="T:Lokad.CurrencyAmount"/>
            </summary>
        </member>
        <member name="M:Lokad.ExtendDecimal.In(System.Decimal,Lokad.CurrencyType)">
            <summary>
            	Converts the specified deimal to a currency.
            </summary>
            <param name="value">The value.</param>
            <param name="currency">The currency.</param>
            <returns>
            	new instance of the currency amount
            </returns>
        </member>
        <member name="M:Lokad.ExtendDecimal.RoundTo(System.Decimal,System.Int32)">
            <summary>
            Rounds the specified decimal with the provided number 
            of fractional digits.
            </summary>
            <param name="value">The value to round.</param>
            <param name="digits">The digits.</param>
            <returns>rounded value</returns>
            <remarks>We can't use "Round" since it will collide with <see cref="M:System.Decimal.Round(System.Decimal,System.Int32)"/></remarks>
        </member>
        <member name="T:Lokad.Diagnostics.Persist.ConversionExtensions">
            <summary>
            Helper extensions for converting to/from data classes in the Diagnostics namespace
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.Persist.ConversionExtensions.ToPersistence(Lokad.Diagnostics.ExecutionStatistics[])">
            <summary>
            Converts immutable statistics objects to the persistence objects
            </summary>
            <param name="statisticsArray">The immutable statistics objects.</param>
            <returns>array of persistence objects</returns>
        </member>
        <member name="M:Lokad.Diagnostics.Persist.ConversionExtensions.FromPersistence(Lokad.Diagnostics.Persist.ExecutionData[])">
            <summary>
            Converts persistence objects to immutable statistics objects
            </summary>
            <param name="dataArray">The persistence data objects.</param>
            <returns>array of statistics objects</returns>
        </member>
        <member name="T:Lokad.Diagnostics.Persist.ExecutionData">
            <summary>
            Diagnostics: Persistence class for aggregated method calls and timing.
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.Persist.ExecutionData.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.Persist.ExecutionData"/> class.
            </summary>
        </member>
        <member name="P:Lokad.Diagnostics.Persist.ExecutionData.Name">
            <summary>
            Name of the executing method
            </summary>
        </member>
        <member name="P:Lokad.Diagnostics.Persist.ExecutionData.OpenCount">
            <summary>
            Number of times the counter has been opened
            </summary>
        </member>
        <member name="P:Lokad.Diagnostics.Persist.ExecutionData.CloseCount">
            <summary>
            Gets or sets the counter has been closed
            </summary>
            <value>The close count.</value>
        </member>
        <member name="P:Lokad.Diagnostics.Persist.ExecutionData.RunningTime">
            <summary>
            Total execution count of the method in ticks
            </summary>
        </member>
        <member name="P:Lokad.Diagnostics.Persist.ExecutionData.Counters">
            <summary>
            Method-specific counters
            </summary>
        </member>
        <member name="T:Lokad.ExtendAction">
            <summary>
            Extensions for the <see cref="T:System.Action"/>
            </summary>
        </member>
        <member name="M:Lokad.ExtendAction.AsDisposable(System.Action)">
            <summary>
            Converts the action into <see cref="T:Lokad.DisposableAction"/>
            </summary>
            <param name="action">The action.</param>
            <returns></returns>
        </member>
        <member name="T:Lokad.ExtendArray">
            <summary>
            Shortcuts for some common array operations
            </summary>
        </member>
        <member name="M:Lokad.ExtendArray.Convert``2(``0[],System.Converter{``0,``1})">
            <summary>
            Shorthand extension method for converting the arrays
            </summary>
            <typeparam name="TSource">The type of the source array.</typeparam>
            <typeparam name="TTarget">The type of the target array.</typeparam>
            <param name="source">The array to convert.</param>
            <param name="converter">The converter.</param>
            <returns>target array instance</returns>
        </member>
        <member name="M:Lokad.ExtendArray.Convert``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
            Shorthand extension method for converting the arrays
            </summary>
            <typeparam name="TSource">The type of the source array.</typeparam>
            <typeparam name="TTarget">The type of the target array.</typeparam>
            <param name="source">The array to convert.</param>
            <param name="converter">The converter, where the second parameter is an index of item being converted.</param>
            <returns>target array instance</returns>
        </member>
        <member name="M:Lokad.ExtendArray.ForEach``1(``0[],System.Action{``0})">
            <summary>
            Applies the action to each item in the array
            </summary>
            <typeparam name="T">type of the items in the array</typeparam>
            <param name="self">The array to walk through.</param>
            <param name="action">The action.</param>
            <returns>Same array instance</returns>
        </member>
        <member name="M:Lokad.ExtendArray.SliceArray``1(``0[],System.Int32)">
            <summary>
            Slices array into array of arrays of length up to <paramref name="sliceLength"/>
            </summary>
            <typeparam name="T">Type of the items int the array</typeparam>
            <param name="array">The array.</param>
            <param name="sliceLength">Length of the slice.</param>
            <returns>array of sliced arrays</returns>
            <exception cref="T:System.ArgumentNullException">When source array is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">When <paramref name="sliceLength"/> is invalid</exception>
        </member>
        <member name="M:Lokad.ExtendArray.ToJaggedArray``1(``0[0:,0:])">
            <summary>
            Converts this array to a jagged array, while bringing indexing to zero-based.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="array">The array.</param>
            <returns>jagged array</returns>
        </member>
        <member name="T:Lokad.IStartable">
            <summary>
            Generic interface for marking startable classes. Opposite for the <see cref="T:System.IDisposable"/>
            </summary>
        </member>
        <member name="M:Lokad.IStartable.StartUp">
            <summary>
            Starts this instance up.
            </summary>
        </member>
        <member name="T:Lokad.Maybe`1">
            <summary>
            Helper class that indicates nullable value in a good-citizenship code
            </summary>
            <typeparam name="T">underlying type</typeparam>
        </member>
        <member name="F:Lokad.Maybe`1.Empty">
            <summary>
            Default empty instance.
            </summary>
        </member>
        <member name="M:Lokad.Maybe`1.GetValue(System.Func{`0})">
            <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Lokad.Maybe`1.GetValue(`0)">
            <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Apply(System.Action{`0})">
            <summary>
            Applies the specified action to the value, if it is present.
            </summary>
            <param name="action">The action.</param>
            <returns>same instance for inlining</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Handle(System.Action)">
            <summary>
            Executes the specified action, if the value is absent
            </summary>
            <param name="action">The action.</param>
            <returns>same instance for inlining</returns>
        </member>
        <member name="M:Lokad.Maybe`1.ExposeException(System.Func{System.Exception})">
            <summary>
            Exposes the specified exception if maybe does not have value.
            </summary>
            <param name="exception">The exception.</param>
            <returns>actual value</returns>
            <exception cref="T:System.Exception">if maybe does not have value</exception>
        </member>
        <member name="M:Lokad.Maybe`1.ExposeException(System.String)">
            <summary>
            Throws the exception if maybe does not have value.
            </summary>
            <returns>actual value</returns>
            <exception cref="T:System.InvalidOperationException">if maybe does not have value</exception>
        </member>
        <member name="M:Lokad.Maybe`1.ExposeException(System.String,System.Object[])">
            <summary>
            Throws the exception if maybe does not have value.
            </summary>
            <returns>actual value</returns>
            <exception cref="T:System.InvalidOperationException">if maybe does not have value</exception>
        </member>
        <member name="M:Lokad.Maybe`1.Combine``1(System.Func{`0,Lokad.Maybe{``0}})">
            <summary>
            Combines this optional with the pipeline function
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="combinator">The combinator (pipeline funcion).</param>
            <returns>optional result</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts this instance to <see cref="T:Lokad.Maybe`1"/>, 
            while applying <paramref name="converter"/> if there is a value.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0},System.Func{``0})">
            <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <typeparam name="TTarget">type of the conversion target</typeparam>
            <param name="converter">The converter.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0},``0)">
            <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <typeparam name="TTarget">type of the conversion target</typeparam>
            <param name="converter">The converter.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Equals(Lokad.Maybe{`0})">
            <summary>
            Determines whether the specified <see cref="T:Lokad.Maybe`1"/> is equal to the current <see cref="T:Lokad.Maybe`1"/>.
            </summary>
            <param name="maybe">The <see cref="T:Lokad.Maybe"/> to compare with.</param>
            <returns>true if the objects are equal</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Maybe`1.GetHashCode">
            <summary>
            Serves as a hash function for this instance.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Lokad.Maybe`1"/>.
            </returns>
        </member>
        <member name="M:Lokad.Maybe`1.op_Equality(Lokad.Maybe{`0},Lokad.Maybe{`0})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Maybe`1.op_Inequality(Lokad.Maybe{`0},Lokad.Maybe{`0})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Maybe`1.op_Implicit(`0)~Lokad.Maybe{`0}">
            <summary>
            Performs an implicit conversion from <typeparamref name="T"/> to <see cref="T:Lokad.Maybe`1"/>.
            </summary>
            <param name="item">The item.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Lokad.Maybe`1.op_Explicit(Lokad.Maybe{`0})~`0">
            <summary>
            Performs an explicit conversion from <see cref="T:Lokad.Maybe`1"/> to <typeparamref name="T"/>.
            </summary>
            <param name="item">The item.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Lokad.Maybe`1.Join``1(``0)">
            <summary>
            Converts maybe into result, using the specified error as the failure
            descriptor
            </summary>
            <typeparam name="TError">The type of the failure.</typeparam>
            <param name="error">The error.</param>
            <returns>result describing current maybe</returns>
        </member>
        <member name="M:Lokad.Maybe`1.JoinMessage(System.String)">
            <summary>
            Converts maybe into result, using the specified error as the failure
            descriptor
            </summary>
            <returns>result describing current maybe</returns>
        </member>
        <member name="M:Lokad.Maybe`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Lokad.Maybe`1.Value">
            <summary>
            Gets the underlying value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Lokad.Maybe`1.HasValue">
            <summary>
            Gets a value indicating whether this instance has value.
            </summary>
            <value><c>true</c> if this instance has value; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Lokad.MaybeParse">
            <summary>
            	Helper routines for converting strings into Maybe
            </summary>
        </member>
        <member name="M:Lokad.MaybeParse.Enum``1(System.String)">
            <summary>
            	Tries to parse the specified string into the enum, returning empty result
            	on failure
            </summary>
            <typeparam name="TEnum">
            	The type of the enum.
            </typeparam>
            <param name="value">The value.</param>
            <returns>
            	either enum or an empty result
            </returns>
        </member>
        <member name="M:Lokad.MaybeParse.Enum``1(System.String,System.Boolean)">
            <summary>
            	Tries to parse the specified string into the enum, returning empty result
            	on failure
            </summary>
            <typeparam name="TEnum">
            	The type of the enum.
            </typeparam>
            <param name="value">The value.</param>
            <param name="ignoreCase">
            	if set to
            	<c>true</c>
            	then parsing will ignore case.
            </param>
            <returns>
            	either enum or an empty result
            </returns>
        </member>
        <member name="M:Lokad.MaybeParse.Decimal(System.String)">
            <summary>
            	Tries to parse the specified value into Decimal, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Decimal or an empty result
            </returns>
            <seealso cref="M:System.Decimal.TryParse(System.String,System.Decimal@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Decimal(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into decimal, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed decimal or an empty result
            </returns>
            <seealso cref="M:System.Decimal.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.DecimalInvariant(System.String)">
            <summary>
            	Tries to parse the specified value into decimal, using the invariant culture
            	info and returning	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed decimal or an empty result
            </returns>
        </member>
        <member name="M:Lokad.MaybeParse.Int32(System.String)">
            <summary>
            	Tries to parse the specified value into Int32, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int32 or an empty result
            </returns>
            <seealso cref="M:System.Int32.TryParse(System.String,System.Int32@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Int32(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Int32, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Int32 or an empty result
            </returns>
            <seealso cref="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Int32Invariant(System.String)">
            <summary>
            	Tries to parse the specified string value into Int32, 
            	using an invariant culture and returning empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int32 or an empty result
            </returns>
            <seealso cref="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Int64(System.String)">
            <summary>
            	Tries to parse the specified value into Int64, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int64 or an empty result
            </returns>
            <seealso cref="M:System.Int64.TryParse(System.String,System.Int64@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Int64(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Int64, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Int64 or an empty result
            </returns>
            <seealso cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Int64Invariant(System.String)">
            <summary>
            	Tries to parse the specified string value into Int64, 
            	using an invariant culture and returning empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int64 or an empty result
            </returns>
            <seealso cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Double(System.String)">
            <summary>
            	Tries to parse the specified value into Double, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Double or an empty result
            </returns>
            <seealso cref="M:System.Double.TryParse(System.String,System.Double@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Double(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Double, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Double or an empty result
            </returns>
            <seealso cref="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.DoubleInvariant(System.String)">
            <summary>
            	Attempts to parse the specified value into Double, 
            	using invariant culture and returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Double or an empty result
            </returns>
            <seealso cref="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Single(System.String)">
            <summary>
            	Tries to parse the specified value into Single, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Single or an empty result
            </returns>
            <seealso cref="M:System.Single.TryParse(System.String,System.Single@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.Single(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Single, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Single or an empty result
            </returns>
            <seealso cref="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)"/>
        </member>
        <member name="M:Lokad.MaybeParse.SingleInvariant(System.String)">
            <summary>
            	Tries to parse the specified value into Single, using invariant culture
            	and returning 	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Single or an empty result
            </returns>
            <seealso cref="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)"/>
        </member>
        <member name="T:Lokad.Quality.ClassDesignAttribute">
            <summary>
            Base attribute for marking classes with some design constraints
            </summary>
        </member>
        <member name="M:Lokad.Quality.ClassDesignAttribute.#ctor(System.String,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.ClassDesignAttribute"/> class.
            </summary>
            <param name="firstDesignTag">The first design tag.</param>
            <param name="otherDesignTags">The other design tags.</param>
        </member>
        <member name="M:Lokad.Quality.ClassDesignAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.ClassDesignAttribute"/> class.
            </summary>
            <param name="classDesignTag">The class design tag.</param>
        </member>
        <member name="M:Lokad.Quality.ClassDesignAttribute.#ctor(Lokad.Quality.DesignTag,Lokad.Quality.DesignTag[])">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.ClassDesignAttribute"/> class.
            </summary>
            <param name="firstDesignTag">The first design tag.</param>
            <param name="otherDesignTags">The other design tags.</param>
        </member>
        <member name="P:Lokad.Quality.ClassDesignAttribute.ClassDesignTags">
            <summary>
            Gets the class design tags.
            </summary>
            <value>The class design tags.</value>
        </member>
        <member name="T:Lokad.Quality.DesignTag">
            <summary>
            	Predefined class design tags
            </summary>
        </member>
        <member name="F:Lokad.Quality.DesignTag.Undefined">
            <summary>Undefined</summary>
        </member>
        <member name="F:Lokad.Quality.DesignTag.Model">
            <summary>
            	The object is a data model
            </summary>
        </member>
        <member name="F:Lokad.Quality.DesignTag.ImmutableWithFields">
            <summary>
            	The object is immutable, using readonly fields
            </summary>
        </member>
        <member name="F:Lokad.Quality.DesignTag.ImmutableWithProperties">
            <summary>
            	The object is immutable, using properties with private setters
            </summary>
        </member>
        <member name="T:Lokad.DesignOfClass">
            <summary>
            	Class design markers for the Lokad namespace
            </summary>
        </member>
        <member name="T:Lokad.DesignOfClass.ImmutableFieldsModel">
            <summary>
            	Indicates that a class is an immutable model with fields
            </summary>
        </member>
        <member name="M:Lokad.DesignOfClass.ImmutableFieldsModel.#ctor">
            <summary>
            	Initializes a new instance of the
            	<see cref="T:Lokad.DesignOfClass.ImmutableFieldsModel"/>
            	class.
            </summary>
        </member>
        <member name="T:Lokad.DesignOfClass.ImmutablePropertiesModel">
            <summary>
            	Indicates that a class is an immutable model with properties
            </summary>
        </member>
        <member name="M:Lokad.DesignOfClass.ImmutablePropertiesModel.#ctor">
            <summary>
            	Initializes a new instance of the
            	<see cref="T:Lokad.DesignOfClass.ImmutablePropertiesModel"/>
            	class.
            </summary>
        </member>
        <member name="T:Lokad.Quality.DesignUtil">
            <summary>
            	Helper class for managing designs
            </summary>
        </member>
        <member name="M:Lokad.Quality.DesignUtil.ConvertTagToString(Lokad.Quality.DesignTag)">
            <summary>
            	Converts the tag to string.
            </summary>
            <param name="tag">The tag.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.Quality.DesignUtil.GetClassDesignTags(System.Type,System.Boolean)">
            <summary>
            	Gets the class design tags.
            </summary>
            <param name="type">The type.</param>
            <param name="inherit">
            	if set to
            	<c>true</c>
            	[inherit].
            </param>
            <returns>
            	array of class design tags
            </returns>
            <remarks>
            	it is advised to cache the results, if performance is important
            </remarks>
        </member>
        <member name="T:Lokad.Quality.DesignUtil.ClassCache`1">
            <summary>
            Simple type cache
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lokad.Quality.DesignUtil.ClassCache`1.Tags">
            <summary>
            Tags for the specified class
            </summary>
        </member>
        <member name="F:Lokad.Quality.DesignUtil.ClassCache`1.IsModel">
            <summary>
            If this class contains a model design tag
            </summary>
        </member>
        <member name="T:Lokad.Quality.LocalizableAttribute">
            <summary>
            Indicates that marked elements is localizable or not.
            </summary>
        </member>
        <member name="M:Lokad.Quality.LocalizableAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.LocalizableAttribute"/> class.
            </summary>
            <param name="isLocalizable"><c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
        </member>
        <member name="M:Lokad.Quality.LocalizableAttribute.Equals(System.Object)">
            <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:Lokad.Quality.LocalizableAttribute"/>.
            </summary>
            <param name="obj">The object to test the value equality of. </param>
            <returns>
            <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Quality.LocalizableAttribute.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A hash code for the current <see cref="T:Lokad.Quality.LocalizableAttribute"/>.</returns>
        </member>
        <member name="P:Lokad.Quality.LocalizableAttribute.IsLocalizable">
            <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value>
            </summary>
        </member>
        <member name="T:Lokad.Rand">
            <summary>
            Helper class that allows to implement non-deterministic 
            reproducible testing.
            </summary>
            <remarks>
            Keep in mind, that this implementation is not thread-safe.
            </remarks>
        </member>
        <member name="M:Lokad.Rand.ResetToDefault">
            <summary>
            Resets everything to the default, using <see cref="T:System.Random"/> generator and random seed. 
            </summary>
        </member>
        <member name="M:Lokad.Rand.ResetToDefault(System.Int32)">
            <summary>
            Resets everything to the default, using <see cref="T:System.Random"/> generator and the specified
            rand seed.
            </summary>
            <param name="randSeed">The rand seed.</param>
        </member>
        <member name="M:Lokad.Rand.Reset">
            <summary>
            Resets the random generator, using the provided activator
            </summary>
        </member>
        <member name="M:Lokad.Rand.Reset(System.Func{System.Func{System.Int32,System.Int32}})">
            <summary>
            Overrides with the current activator
            </summary>
            <param name="activator">The activator.</param>
        </member>
        <member name="M:Lokad.Rand.Next">
            <summary>
            Generates random value between 0 and <see cref="F:System.Int32.MaxValue"/> (exclusive)
            </summary>
            <returns>random integer</returns>
        </member>
        <member name="M:Lokad.Rand.Next(System.Int32)">
            <summary>
            Generates random value between 0 and <paramref name="upperBound"/> (exclusive)
            </summary>
            <param name="upperBound">The upper bound.</param>
            <returns>random integer</returns>
        </member>
        <member name="M:Lokad.Rand.Next(System.Int32,System.Int32)">
            <summary>
            Generates random value between <paramref name="lowerBound"/>
            and <paramref name="upperBound"/> (exclusive)
            </summary>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
            <returns>random integer</returns>
        </member>
        <member name="M:Lokad.Rand.NextItem``1(``0[])">
            <summary> Picks random item from the provided array </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="items">The items.</param>
            <returns>random item from the array</returns>
        </member>
        <member name="M:Lokad.Rand.NextEnum``1">
            <summary> Picks random <see cref="T:System.Enum"/> </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <returns>random Enum value</returns>
        </member>
        <member name="M:Lokad.Rand.NextEnumExceptDefault``1">
            <summary> Picks random <see cref="T:System.Enum"/> where the item is not equal to
            default(TEnum)</summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <returns>random Enum value</returns>
        </member>
        <member name="M:Lokad.Rand.NextBool(System.Double)">
            <summary>
            Returns <em>true</em> with the specified probability.
            </summary>
            <param name="probability">The probability (between 0 and 1).</param>
            <returns><em>true</em> with the specified probability</returns>
        </member>
        <member name="M:Lokad.Rand.NextBool">
            <summary>
            Returns either <em>true</em> or <em>false</em>
            </summary>
            <returns>either <em>true</em> or <em>false</em></returns>
        </member>
        <member name="M:Lokad.Rand.NextMaybe``1(``0)">
            <summary>
            Creates random optional that might have the value
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="value">The value.</param>
            <returns>optional that might have the value</returns>
        </member>
        <member name="M:Lokad.Rand.NextGuid">
            <summary> Picks random <see cref="T:System.Guid"/>  </summary>
            <returns>random value</returns>
        </member>
        <member name="M:Lokad.Rand.NextGuids(System.Int32)">
            <summary>
            Creates an array of random <see cref="T:System.Guid"/>
            </summary>
            <param name="count">Number of items in the array.</param>
            <returns>random value</returns>
        </member>
        <member name="M:Lokad.Rand.NextGuids(System.Int32,System.Int32)">
            <summary>
            Creates an array of random <see cref="T:System.Guid"/> and random length.
            </summary>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.Rand.NextDouble">
            <summary> Returns random double value with lowered precision </summary>
            <returns>random double value</returns>
        </member>
        <member name="M:Lokad.Rand.NextDate">
            <summary>
            Returns a random date between 1700-01-01 and 2100-01-01
            </summary>
            <returns>random value</returns>
        </member>
        <member name="M:Lokad.Rand.NextDate(System.Int32,System.Int32)">
            <summary>
            Returns a random date between the specified range.
            </summary>
            <param name="minYear">The min year.</param>
            <param name="maxYear">The max year.</param>
            <returns>new random date</returns>
        </member>
        <member name="M:Lokad.Rand.NextString(System.Int32,System.Int32)">
            <summary>
            Generates random string with the length between 
            <paramref name="lowerBound"/> and <paramref name="upperBound"/> (exclusive)
            </summary>
            <param name="lowerBound">The lower bound for the string length.</param>
            <param name="upperBound">The upper bound for the string length.</param>
            <returns>new random string</returns>
        </member>
        <member name="M:Lokad.Rand.NextItems``1(``0[],System.Int32)">
            <summary>
            Gets a random subset from the array
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="items">The items.</param>
            <param name="count">The count.</param>
            <returns>array that contains <paramref name="count"/> items from the original array</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">when <paramref name="count"/> 
            is bigger than the length of <paramref name="items"/></exception>
        </member>
        <member name="T:Lokad.Rand.String">
            <summary>
            Helper random methods related to strings
            </summary>
        </member>
        <member name="M:Lokad.Rand.String.NextSentence(System.Int32,System.Int32)">
            <summary>
            Gets the Lorem Ipsum sentence with random word count.
            </summary>
            <param name="lowerBound">The lower bound for the word count (inclusive).</param>
            <param name="upperBound">The upper bound for the word count (exclusive).</param>
            <returns>random sentence of Lorem ipsum</returns>
        </member>
        <member name="M:Lokad.Rand.String.NextWord">
            <summary>
            Gets random word from the Lorem Ipsum dictionary.
            </summary>
            <returns>random word from the Lorem Ipsum dictionary</returns>
        </member>
        <member name="M:Lokad.Rand.String.NextText(System.Int32,System.Int32)">
            <summary>
            Gets the Lorem ipsum text with the random word count.
            </summary>
            <param name="lowerBound">The lower bound for the word count (inclusive).</param>
            <param name="upperBound">The upper bound for the word count (exclusive).</param>
            <returns>random text of Lorem Ipsum</returns>
        </member>
        <member name="T:Lokad.Result`1">
            <summary>
            Helper class that allows to pass out method call results without using exceptions
            </summary>
            <typeparam name="T">type of the associated data</typeparam>
        </member>
        <member name="M:Lokad.Result`1.CreateError(System.String,System.Object[])">
            <summary>  Creates failure result </summary>
            <param name="errorFormatString">format string for the error message</param>
            <param name="args">The arguments.</param>
            <returns>result that is a failure</returns>
            <exception cref="T:System.ArgumentNullException">if format string is null</exception>
        </member>
        <member name="M:Lokad.Result`1.CreateSuccess(`0)">
            <summary>
            Creates the success result.
            </summary>
            <param name="value">The value.</param>
            <returns>result encapsulating the success value</returns>
            <exception cref="T:System.ArgumentNullException">if value is a null reference type</exception>
        </member>
        <member name="M:Lokad.Result`1.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts value of this instance
            using the provided <paramref name="converter"/>
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Converted result</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="converter"/> is null</exception>
        </member>
        <member name="M:Lokad.Result`1.CreateError(System.String)">
            <summary>
            Creates the error result.
            </summary>
            <param name="error">The error.</param>
            <returns>result encapsulating the error value</returns>
            <exception cref="T:System.ArgumentNullException">if error is null</exception>
        </member>
        <member name="M:Lokad.Result`1.op_Implicit(`0)~Lokad.Result{`0}">
            <summary>
            Performs an implicit conversion from <typeparamref name="T"/> to <see cref="T:Lokad.Result`1"/>.
            </summary>
            <param name="value">The item.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="value"/> is a reference type that is null</exception>
        </member>
        <member name="M:Lokad.Result`1.Combine``1(System.Func{`0,Lokad.Result{``0}})">
            <summary>
            Combines this <see cref="T:Lokad.Result`1"/> with the result returned
            by <paramref name="converter"/>.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Combined result.</returns>
        </member>
        <member name="M:Lokad.Result`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Result`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Lokad.Result`1.Equals(Lokad.Result{`0})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Lokad.Result`1.Apply(System.Action{`0})">
            <summary>
            Applies the specified <paramref name="action"/>
            to this <see cref="T:Lokad.Result`1"/>, if it has value.
            </summary>
            <param name="action">The action to apply.</param>
            <returns>returns same instance for inlining</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="action"/> is null</exception>
        </member>
        <member name="M:Lokad.Result`1.Handle(System.Action{System.String})">
            <summary>
            Handles the specified handler.
            </summary>
            <param name="handler">The handler.</param>
            <returns>same instance for the inlining</returns>
        </member>
        <member name="M:Lokad.Result`1.ToMaybe``1(System.Func{`0,``0})">
            <summary>
            Converts this <see cref="T:Lokad.Result`1"/> to <see cref="T:Lokad.Maybe`1"/>, 
            using the <paramref name="converter"/> to perform the value conversion.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The reflector.</param>
            <returns><see cref="T:Lokad.Maybe`1"/> that represents the original value behind the <see cref="T:Lokad.Result`1"/> after the conversion</returns>
        </member>
        <member name="M:Lokad.Result`1.ToMaybe">
            <summary>
            Converts this <see cref="T:Lokad.Result`1"/> to <see cref="T:Lokad.Maybe`1"/>, 
            with the original value reference, if there is any.
            </summary>
            <returns><see cref="T:Lokad.Maybe`1"/> that represents the original value behind the <see cref="T:Lokad.Result`1"/>.</returns>
        </member>
        <member name="M:Lokad.Result`1.ExposeException(System.Func{System.String,System.Exception})">
            <summary>
            Exposes result failure as the exception (providing compatibility, with the exception -expecting code).
            </summary>
            <param name="exception">The function to generate exception, provided the error string.</param>
            <returns>result value</returns>
        </member>
        <member name="M:Lokad.Result`1.op_Implicit(System.String)~Lokad.Result{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Lokad.Result`1"/>.
            </summary>
            <param name="error">The error.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
        </member>
        <member name="M:Lokad.Result`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Lokad.Result`1.ErrorMessage">
            <summary>
            Error message associated with this failure
            </summary>
        </member>
        <member name="P:Lokad.Result`1.IsSuccess">
            <summary>
            Gets a value indicating whether this result is valid.
            </summary>
            <value><c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Lokad.Result`1.Value">
            <summary>
            item associated with this result
            </summary>
        </member>
        <member name="P:Lokad.Result`1.Error">
            <summary>
            Error message associated with this failure
            </summary>
        </member>
        <member name="T:Lokad.Result`2">
            <summary>
            Improved version of the Result[T], that could serve as a basis for it.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TError">The type of the error.</typeparam>
            <remarks>It is to be moved up-stream if found useful in other projects.</remarks>
        </member>
        <member name="M:Lokad.Result`2.CreateSuccess(`0)">
            <summary>
            Creates the success result.
            </summary>
            <param name="value">The value.</param>
            <returns>result encapsulating the success value</returns>
            <exception cref="T:System.ArgumentNullException">if value is a null reference type</exception>
        </member>
        <member name="M:Lokad.Result`2.CreateError(`1)">
            <summary>
            Creates the error result.
            </summary>
            <param name="error">The error.</param>
            <returns>result encapsulating the error value</returns>
            <exception cref="T:System.ArgumentNullException">if error is a null reference type</exception>
        </member>
        <member name="M:Lokad.Result`2.op_Implicit(`0)~Lokad.Result{`0,`1}">
            <summary>
            Performs an implicit conversion from <typeparamref name="TValue"/> to <see cref="T:Lokad.Result`2"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
        </member>
        <member name="M:Lokad.Result`2.op_Implicit(`1)~Lokad.Result{`0,`1}">
            <summary>
            Performs an implicit conversion from <typeparamref name="TError"/> to <see cref="T:Lokad.Result`2"/>.
            </summary>
            <param name="error">The error.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
        </member>
        <member name="M:Lokad.Result`2.Equals(Lokad.Result{`0,`1})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Lokad.Result`2.Apply(System.Action{`0})">
            <summary>
            Applies the specified <paramref name="action"/>
            to this <see cref="T:Lokad.Result`1"/>, if it has value.
            </summary>
            <param name="action">The action to apply.</param>
            <returns>returns same instance for inlining</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="action"/> is null</exception>
        </member>
        <member name="M:Lokad.Result`2.Handle(System.Action{`1})">
            <summary>
            Handles the specified handler.
            </summary>
            <param name="handler">The handler.</param>
            <returns>same instance for the inlining</returns>
        </member>
        <member name="M:Lokad.Result`2.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts value of this instance
            using the provided <paramref name="converter"/>
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Converted result</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="converter"/> is null</exception>
        </member>
        <member name="M:Lokad.Result`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Result`2.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Lokad.Result`2.Combine``1(System.Func{`0,Lokad.Result{``0,`1}})">
            <summary>
            Combines this <see cref="T:Lokad.Result`1"/> with the result returned
            by <paramref name="converter"/>.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Combined result.</returns>
        </member>
        <member name="M:Lokad.Result`2.ToMaybe``1(System.Func{`0,``0})">
            <summary>
            Converts this <see cref="T:Lokad.Result`1"/> to <see cref="T:Lokad.Maybe`1"/>, 
            using the <paramref name="converter"/> to perform the value conversion.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The reflector.</param>
            <returns><see cref="T:Lokad.Maybe`1"/> that represents the original value behind the <see cref="T:Lokad.Result`1"/> after the conversion</returns>
        </member>
        <member name="M:Lokad.Result`2.ToMaybe">
            <summary>
            Converts this <see cref="T:Lokad.Result`1"/> to <see cref="T:Lokad.Maybe`1"/>, 
            with the original value reference, if there is any.
            </summary>
            <returns><see cref="T:Lokad.Maybe`1"/> that represents the original value behind the <see cref="T:Lokad.Result`1"/>.</returns>
        </member>
        <member name="M:Lokad.Result`2.ExposeException(System.Func{`1,System.Exception})">
            <summary>
            Exposes result failure as the exception (providing compatibility, with the exception -expecting code).
            </summary>
            <param name="exception">The function to generate exception, provided the error string.</param>
            <returns>result value</returns>
        </member>
        <member name="M:Lokad.Result`2.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Lokad.Result`2.Value">
            <summary>
            item associated with this result
            </summary>
        </member>
        <member name="P:Lokad.Result`2.Error">
            <summary>
            Error message associated with this failure
            </summary>
        </member>
        <member name="P:Lokad.Result`2.IsSuccess">
            <summary>
            Gets a value indicating whether this result is valid.
            </summary>
            <value><c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Lokad.ResultResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Lokad.ResultResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Lokad.ResultResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Lokad.ResultResources.Dont_access_error_on_valid_result">
            <summary>
              Looks up a localized string similar to Code should not access error message when the result is valid..
            </summary>
        </member>
        <member name="P:Lokad.ResultResources.Dont_access_result_on_error_X">
            <summary>
              Looks up a localized string similar to Code should not access value when the result has failed. Error is: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.ResultResources.Dont_access_value_when_maybe_is_empty">
            <summary>
              Looks up a localized string similar to Code should not access value when it is not available..
            </summary>
        </member>
        <member name="T:Lokad.Reflection.ReflectLambdaException">
            <summary>
            Exception thrown, when <see cref="T:Lokad.Reflection.Reflect"/> fails to parse some lambda
            </summary>
        </member>
        <member name="M:Lokad.Reflection.ReflectLambdaException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Reflection.ReflectLambdaException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Lokad.Rules.BufferIs">
            <summary>
            Validation rules for byte arrays
            </summary>
        </member>
        <member name="M:Lokad.Rules.BufferIs.Limited(System.Int32)">
            <summary>
            Composes validator ensuring that size of the buffer 
            is equal or less to the speicifed limit 
            </summary>
            <param name="length">The length.</param>
            <returns>new rule validator instance</returns>
        </member>
        <member name="M:Lokad.Rules.BufferIs.WithValidHash(System.Int32)">
            <summary>
            Composes validator ensuring that buffer has valid hash
            </summary>
            <param name="hash">The hash.</param>
            <returns>new instance of the rule validato</returns>
            <seealso cref="M:Lokad.BufferUtil.CalculateSimpleHashCode(System.Byte[])"/>
        </member>
        <member name="T:Lokad.Rules.MaybeIs">
            <summary>
            Common rules for handling Maybe{T} values.
            </summary>
        </member>
        <member name="M:Lokad.Rules.MaybeIs.EmptyOr``1(Lokad.Rules.Rule{``0}[])">
            <summary>
            Generates rule that is valid if the provided optional
            is either empty or passes the supplied value rules
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="valueRules">The value rules.</param>
            <returns>new validation rule</returns>
        </member>
        <member name="M:Lokad.Rules.MaybeIs.ValidAnd``1(Lokad.Rules.Rule{``0}[])">
            <summary>
            Generates the rule that ensures the provided optional to be
            valid and passing the provided rules
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="valueRules">The value rules.</param>
            <returns>new validation rules</returns>
        </member>
        <member name="T:Lokad.Settings.ISettingsRepository">
            <summary>
            	Simple repository that merely loads all available
            	and applicable settings for this instance.
            	Tenant filtering and other options, if applicable,
            	would be hidden behind this interface
            </summary>
        </member>
        <member name="M:Lokad.Settings.ISettingsRepository.LoadSettings">
            <summary>
            	Loads the currently active settings from the repo.
            </summary>
            <returns>
            	dictionary containing settings
            </returns>
        </member>
        <member name="T:Lokad.Settings.DictionarySettingsProvider">
            <summary>
            Settings provider based on a simple dictionary
            </summary>
        </member>
        <member name="T:Lokad.Settings.ISettingsProvider">
            <summary>
            	Simple settings reader
            </summary>
        </member>
        <member name="M:Lokad.Settings.ISettingsProvider.GetValue(System.String)">
            <summary>
            	Gets the value, using the given key name.
            </summary>
            <param name="name">The name.</param>
            <returns>
            	value for the specified key name, or empty result
            </returns>
        </member>
        <member name="M:Lokad.Settings.ISettingsProvider.Filtered(Lokad.Settings.ISettingsKeyFilter)">
            <summary>
            	Creates new provider that contains only values filtered by the acceptor
            </summary>
            <param name="acceptor">The acceptor.</param>
            <returns>
            	new settings provider that had been filtered
            </returns>
        </member>
        <member name="M:Lokad.Settings.DictionarySettingsProvider.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Settings.DictionarySettingsProvider"/> class.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="T:Lokad.Settings.ExtendISettingsProvider">
            <summary>
            	Adds extensions for the simplicity of settings use.
            </summary>
        </member>
        <member name="M:Lokad.Settings.ExtendISettingsProvider.AsSettingsProvider(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            	Converts given dictionary to the settings provider.
            </summary>
            <param name="dict">The dict.</param>
            <returns>
            	new instance of the settings provider
            </returns>
        </member>
        <member name="M:Lokad.Settings.ExtendISettingsProvider.FilteredByPrefix(Lokad.Settings.ISettingsProvider,System.String)">
            <summary>
            	Creates new settings provider, using the
            	<see cref="T:Lokad.Settings.PrefixTruncatingKeyFilter"/>
            	for the path filtering logic
            </summary>
            <param name="settingsProvider">
            	The settings provider.
            </param>
            <param name="prefix">
            	The prefix to look for and then truncate.
            </param>
            <returns>
            	new instance of the settings provider, created by filtering and applying transformations
            </returns>
        </member>
        <member name="T:Lokad.Settings.ISettingsKeyFilter">
            <summary>
            	Implements filtering interface for the
            	<see cref="T:Lokad.Settings.ISettingsProvider"/>
            </summary>
        </member>
        <member name="M:Lokad.Settings.ISettingsKeyFilter.Filter(System.String)">
            <summary>
            	Filters the path, either accepting it (and optionally altering)
            	or by returning empty result
            </summary>
            <param name="keyPath">The key path.</param>
            <returns>filtered key path</returns>
        </member>
        <member name="T:Lokad.Settings.PrefixTruncatingKeyFilter">
            <summary>
            	Simple prefix-based path acceptor, that removes prefix from the path after match
            </summary>
        </member>
        <member name="M:Lokad.Settings.PrefixTruncatingKeyFilter.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the
            	<see cref="T:Lokad.Settings.PrefixTruncatingKeyFilter"/>
            	class.
            </summary>
            <param name="prefix">The prefix.</param>
        </member>
        <member name="T:Lokad.Syntax`1">
            <summary>
            Helper class for creating fluent APIs
            </summary>
            <typeparam name="T">underlying type</typeparam>
        </member>
        <member name="T:Lokad.Syntax">
            <summary>
            Helper class for creating fluent APIs, that hides unused signatures
            </summary>
        </member>
        <member name="M:Lokad.Syntax.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Lokad.Syntax.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Syntax.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Lokad.Syntax.GetType">
            <summary>
            Gets the <see cref="T:System.Type"/> of the current instance.
            </summary>
            <returns>
            The <see cref="T:System.Type"/> instance that represents the exact runtime type of the current instance.
            </returns>
        </member>
        <member name="M:Lokad.Syntax.For``1(``0)">
            <summary>
            Creates the syntax for the specified target
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="inner">The inner.</param>
            <returns>new syntax instance</returns>
        </member>
        <member name="M:Lokad.Syntax`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Syntax`1"/> class.
            </summary>
            <param name="inner">The underlying instance.</param>
        </member>
        <member name="P:Lokad.Syntax`1.Target">
            <summary>
            Gets the underlying object.
            </summary>
            <value>The underlying object.</value>
        </member>
        <member name="T:Lokad.Testing.Equatable">
            <summary>
            Helper extensions for the <see cref="T:System.IEquatable`1"/> used in testing of models.
            </summary>
        </member>
        <member name="M:Lokad.Testing.Equatable.EqualsTo``1(System.IEquatable{``0},``0)">
            <summary>
            Checks if the specified object instance is equal to another instance
            </summary>
            <typeparam name="TObject">The type of the object.</typeparam>
            <param name="self">The object to check.</param>
            <param name="other">The other object to compare with.</param>
            <returns><c>True</c> if the object instances are equal</returns>
        </member>
        <member name="M:Lokad.Testing.Equatable.EqualsTo``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            Checks if the specified collection of object instances is equal to another similar collection
            </summary>
            <typeparam name="TObject">The type of the object.</typeparam>
            <param name="self">The collection to check.</param>
            <param name="other">The other collection.</param>
            <returns><c>True</c> if all object instances are equal</returns>
        </member>
        <member name="T:System.Linq.ArrayExtensionsForLinq">
            <summary>
            Array extensions that belong to the LINQ namespace
            </summary>
        </member>
        <member name="M:System.Linq.ArrayExtensionsForLinq.Append``1(``0[],``0[])">
            <summary>
            Joins arrays together
            </summary>
            <typeparam name="T">type of the arrays</typeparam>
            <param name="self">The first array to join.</param>
            <param name="second">The second array to join.</param>
            <returns>Joined array</returns>
        </member>
        <member name="T:System.Linq.Indexer`1">
            <summary>
            Indexing wrapper that contains value and its integral position.
            </summary>
            <typeparam name="TSource">type of the underlying item</typeparam>
        </member>
        <member name="P:System.Linq.Indexer`1.Index">
            <summary>
            Gets the integral position of the item.
            </summary>
            <value>The integral position of the item.</value>
        </member>
        <member name="P:System.Linq.Indexer`1.IsFirst">
            <summary>
            Gets a value indicating whether this instance is first.
            </summary>
            <value><c>true</c> if this instance is first; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:System.Linq.Indexer`1.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="T:Lokad.Maybe">
            <summary>
            Helper routines for <see cref="T:Lokad.Maybe`1"/>
            </summary>
        </member>
        <member name="M:Lokad.Maybe.From``1(``0)">
            <summary>
            Creates new <see cref="T:Lokad.Maybe`1"/> from the provided value
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="item">The item.</param>
            <returns><see cref="T:Lokad.Maybe`1"/> that matches the provided value</returns>
            <exception cref="T:System.ArgumentNullException">if argument is a null reference</exception>
        </member>
        <member name="F:Lokad.Maybe.Bool">
            <summary>
            Optional empty boolean
            </summary>
        </member>
        <member name="F:Lokad.Maybe.String">
            <summary>
            Optional empty string
            </summary>
        </member>
        <member name="T:Lokad.Quality.ImmutableAttribute">
            <summary>
            <para>Class is considered to be immutable, when all fields are read-only.
            This makes the class safe for the multi-threaded operations.</para>
            <para>This attribute is used as a marker for code validation that actually enforced the rule</para>
            </summary>
        </member>
        <member name="M:Lokad.Quality.ImmutableAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.ImmutableAttribute"/> class.
            </summary>
        </member>
        <member name="T:Lokad.Quality.NoCodeCoverageAttribute">
            <summary>
            Attribute used to inform code coverage tool to ignore marked code block
            </summary>
        </member>
        <member name="P:Lokad.Quality.NoCodeCoverageAttribute.Justification">
            <summary> Gets or sets the justification for removing 
            the member from the unit test code coverage. </summary>
            <value>The justification.</value>
        </member>
        <member name="T:Lokad.Quality.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:Lokad.Quality.AssertionMethodAttribute"/> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
            <seealso cref="T:Lokad.Quality.AssertionConditionType"/>
            <remarks>This attribute helps R# in code analysis</remarks>
        </member>
        <member name="M:Lokad.Quality.AssertionConditionAttribute.#ctor(Lokad.Quality.AssertionConditionType)">
            <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
            <param name="conditionType">Specifies condition type</param>
        </member>
        <member name="P:Lokad.Quality.AssertionConditionAttribute.ConditionType">
            <summary>
            Gets condition type
            </summary>
        </member>
        <member name="T:Lokad.Quality.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:Lokad.Quality.AssertionConditionType.IS_TRUE">
            <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
        </member>
        <member name="F:Lokad.Quality.AssertionConditionType.IS_FALSE">
            <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
        </member>
        <member name="F:Lokad.Quality.AssertionConditionType.IS_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
        </member>
        <member name="F:Lokad.Quality.AssertionConditionType.IS_NOT_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
        </member>
        <member name="T:Lokad.Quality.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:Lokad.Quality.AssertionConditionAttribute"/> attribute
            </summary>
            <seealso cref="T:Lokad.Quality.AssertionConditionAttribute"/>
            <remarks>This attribute helps R# in code analysis</remarks>
        </member>
        <member name="T:Lokad.Quality.CanBeNullAttribute">
            <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
        </member>
        <member name="T:Lokad.Quality.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
        </member>
        <member name="T:Lokad.Quality.ImplicitUseFlags">
            <summary>
            Used by <see cref="T:Lokad.Quality.MeansImplicitUseAttribute"/>
            </summary>
        </member>
        <member name="F:Lokad.Quality.ImplicitUseFlags.STANDARD">
            <summary>
            Standard
            </summary>
        </member>
        <member name="F:Lokad.Quality.ImplicitUseFlags.ALL_MEMBERS_USED">
            <summary>
            All members used
            </summary>
        </member>
        <member name="T:Lokad.Quality.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException"/> has such parameter.
            </summary>
            <remarks>This attribute helps R# in code analysis</remarks>
        </member>
        <member name="T:Lokad.Quality.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
            <remarks>This attribute helps R# in code analysis</remarks>
        </member>
        <member name="M:Lokad.Quality.MeansImplicitUseAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.MeansImplicitUseAttribute"/> class with <see cref="F:Lokad.Quality.ImplicitUseFlags.STANDARD"/>.
            </summary>
        </member>
        <member name="M:Lokad.Quality.MeansImplicitUseAttribute.#ctor(Lokad.Quality.ImplicitUseFlags)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.MeansImplicitUseAttribute"/> class.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="P:Lokad.Quality.MeansImplicitUseAttribute.Flags">
            <summary>
            Gets the flags.
            </summary>
            <value>The flags.</value>
        </member>
        <member name="T:Lokad.Quality.NotNullAttribute">
            <summary>
            Indicates that the value of marked element could never be <c>null</c>
            </summary>
        </member>
        <member name="T:Lokad.Quality.StringFormatMethodAttribute">
            <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
            <remarks>
            This attribute helps R# in code analysis
            </remarks>
        </member>
        <member name="M:Lokad.Quality.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:Lokad.Quality.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
        <member name="T:Lokad.Quality.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
        </member>
        <member name="T:Lokad.Quality.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (ex. reflection, external library), 
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
            <remarks>This attribute helps R# in code analysis</remarks>
        </member>
        <member name="T:Lokad.Reflection.Express">
            <summary>
            Helper class for the Expression-based strongly-typed reflection
            </summary>
        </member>
        <member name="M:Lokad.Reflection.Express.MethodWithLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Gets the <see cref="T:System.Reflection.MethodInfo"/> 
            from the provided <paramref name="method"/>.
            </summary>
            <param name="method">The method expression.</param>
            <returns>method information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.ConstructorWithLamda(System.Linq.Expressions.LambdaExpression)">
            <summary> Gets the <see cref="T:System.Reflection.ConstructorInfo"/> from the 
            provided <paramref name="constructor"/> lambda. </summary>
            <param name="constructor">The constructor expression.</param>
            <returns>constructor information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)">
            <summary> Gets the <see cref="T:System.Reflection.MemberInfo"/> (field or property) 
            from the  provided <paramref name="member"/> </summary>
            <param name="member">The property expression.</param>
            <returns>member information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.PropertyWithLambda(System.Linq.Expressions.LambdaExpression)">
            <summary> Gets the <see cref="T:System.Reflection.PropertyInfo"/> from the provided
            <paramref name="property"/> expression. </summary>
            <param name="property">The property expression.</param>
            <returns>property information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.FieldWithLambda(System.Linq.Expressions.LambdaExpression)">
            <summary> Gets the <see cref="T:System.Reflection.FieldInfo"/> from the provided 
            <paramref name="field"/> expression. </summary>
            <param name="field">The field expression.</param>
            <returns>field information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.Method(System.Linq.Expressions.Expression{System.Action})">
            <summary> Gets the <see cref="T:System.Reflection.MethodInfo"/> 
            from the provided <paramref name="method"/>.
            </summary>
            <param name="method">The method expression.</param>
            <returns>method information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.Constructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the <see cref="T:System.Reflection.ConstructorInfo"/> 
            from the provided <paramref name="constructorExpression"/>.
            </summary>
            <param name="constructorExpression">The constructor expression.</param>
            <returns>constructor information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.Property``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary> Gets the <see cref="T:System.Reflection.PropertyInfo"/> from the provided
            <paramref name="property"/> expression. </summary>
            <param name="property">The property expression.</param>
            <returns>property information</returns>
        </member>
        <member name="M:Lokad.Reflection.Express.Field``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary> Gets the <see cref="T:System.Reflection.FieldInfo"/> from the provided 
            <paramref name="field"/> expression. </summary>
            <param name="field">The field expression.</param>
            <returns>field information</returns>
        </member>
        <member name="T:Lokad.Reflection.Express`1">
            <summary>
            Helper class for the Expression-based strongly-typed reflection
            </summary>
        </member>
        <member name="M:Lokad.Reflection.Express`1.Method(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary> Gets the <see cref="T:System.Reflection.MethodInfo"/> from 
            the provided <paramref name="method"/> expression. </summary>
            <param name="method">The expression.</param>
            <returns>method information</returns>
            <seealso cref="M:Lokad.Reflection.Express.MethodWithLambda(System.Linq.Expressions.LambdaExpression)"/>
        </member>
        <member name="M:Lokad.Reflection.Express`1.Property``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary> Gets the <see cref="T:System.Reflection.PropertyInfo"/> from the provided
            <paramref name="property"/> expression. </summary>
            <param name="property">The property expression.</param>
            <returns>property information</returns>
            <seealso cref="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)"/>
            <seealso cref="M:Lokad.Reflection.Express.PropertyWithLambda(System.Linq.Expressions.LambdaExpression)"/>
        </member>
        <member name="M:Lokad.Reflection.Express`1.Field``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary> Gets the <see cref="T:System.Reflection.FieldInfo"/> from the provided 
            <paramref name="field"/> expression. </summary>
            <param name="field">The field expression.</param>
            <returns>field information</returns>
            <seealso cref="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)"/>
            <seealso cref="M:Lokad.Reflection.Express.FieldWithLambda(System.Linq.Expressions.LambdaExpression)"/>
        </member>
        <member name="T:Lokad.Rules.RuleResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Buffer_cant_be_longer_than_X">
            <summary>
              Looks up a localized string similar to Byte array should not be longer than {0} bytes..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Buffer_must_have_valid_hash">
            <summary>
              Looks up a localized string similar to Byte array should have valid hash..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Collection_X_cant_be_null">
            <summary>
              Looks up a localized string similar to Collection of type &apos;{0}&apos; should not be null..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Date_must_be_greater_than_X">
            <summary>
              Looks up a localized string similar to Date must be greater than &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Double_must_represent_valid_value">
            <summary>
              Looks up a localized string similar to Double should represent a valid value..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Expression_X_must_be_true">
            <summary>
              Looks up a localized string similar to Expression should be true: {0}..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Maybe_X_cant_be_empty">
            <summary>
              Looks up a localized string similar to Optional &apos;{0}&apos; should not be empty..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Object_must_be_same_as_reference">
            <summary>
              Looks up a localized string similar to Object should be same as the provided reference..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Object_X_cant_be_null">
            <summary>
              Looks up a localized string similar to Object of type &apos;{0}&apos; should not be null..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.RuleException_header">
            <summary>
              Looks up a localized string similar to Rule messages:.
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_be_empty">
            <summary>
              Looks up a localized string similar to String should not be empty..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_be_longer_than_X">
            <summary>
              Looks up a localized string similar to String should not be longer than {0} characters..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_be_shorter_than_X">
            <summary>
              Looks up a localized string similar to String should not be shorter than {0} characters..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_contain_unicode_control_characters">
            <summary>
              Looks up a localized string similar to String should not contain unicode control characters..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_contain_uppercase">
            <summary>
              Looks up a localized string similar to String should not have uppercase characters..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_contain_X_characters">
            <summary>
              Looks up a localized string similar to String should not contain following characters: {0}..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_end_with_whitespace">
            <summary>
              Looks up a localized string similar to String should not end with trailing white-space character..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_cant_start_with_whitespace">
            <summary>
              Looks up a localized string similar to String should not start with white-space character..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_must_be_valid_email">
            <summary>
              Looks up a localized string similar to String should be a valid email address..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.String_must_be_valid_host">
            <summary>
              Looks up a localized string similar to String should be a valid host name..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Value_cant_be_equal_to_X">
            <summary>
              Looks up a localized string similar to Value should not be equal to &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Value_cant_be_greater_than_X">
            <summary>
              Looks up a localized string similar to Value should not be greater than &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Value_cant_be_less_than_X">
            <summary>
              Looks up a localized string similar to Value should not be less than &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Value_must_be_equal_to_X">
            <summary>
              Looks up a localized string similar to Value should be equal to &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Value_must_be_greater_than_X">
            <summary>
              Looks up a localized string similar to Value should be greater than &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleResources.Value_must_be_less_than_X">
            <summary>
              Looks up a localized string similar to Value should be less than &apos;{0}&apos;..
            </summary>
        </member>
        <member name="T:Lokad.Rules.ModifierScope">
            <summary>
            Simple <see cref="T:Lokad.Rules.IScope"/> implementation that allows to 
            modify the behavior of the underlying scopes
            </summary>
        </member>
        <member name="T:Lokad.Rules.IScope">
            <summary>
            Concept from the xLim2. That's simple nesting logger that is used by
            the validation rules. 
            </summary>
            <remarks>
            <para>It has logical the extensibility (not implemented, because there
            does not seem to be any need) for maintaining the error level in
            attached and detached scopes. Warnings, Fatals or Info messages
            could be added here (full ILogScope if needed).</para>
            <para>  Same extensibility
            could be turned on for capturing detailed validation info on complex
            long-running validation scenarios (you'd hate to debug these). </para>
            <para> Note, that in order to maintain .NET 2.0 compatibility,
            is is recommended to use interface-declared methods instead of the
            extensions (or use some extension weaver).</para>
            </remarks>
        </member>
        <member name="M:Lokad.Rules.IScope.Create(System.String)">
            <summary>
            Creates the nested scope with the specified name.
            </summary>
            <param name="name">New name for the nested scope.</param>
            <returns>Nested (and linked) scope instance</returns>
        </member>
        <member name="M:Lokad.Rules.IScope.Write(Lokad.Rules.RuleLevel,System.String)">
            <summary>
            Writes <paramref name="message"/> with the specified
            <paramref name="level"/> to the <see cref="T:Lokad.Rules.IScope"/>
            </summary>
            <param name="level">The level.</param>
            <param name="message">The message.</param>
        </member>
        <member name="P:Lokad.Rules.IScope.Level">
            <summary>
            Gets the current <see cref="T:Lokad.Rules.RuleLevel"/> of this scope
            </summary>
            <value>The level.</value>
        </member>
        <member name="T:Lokad.Rules.DelayedScope">
            <summary>
            This scope is just like <see cref="T:Lokad.Rules.SimpleScope"/>
            but it delays name resolution
            </summary>
        </member>
        <member name="T:Lokad.Rules.SimpleScope">
            <summary>
            <see cref="T:Lokad.Rules.IScope"/> that maintains scope path, executes 
            <see cref="T:Lokad.Rules.SimpleScope.Messenger"/> delegate per every message.
            </summary>
        </member>
        <member name="M:Lokad.Rules.SimpleScope.#ctor(System.String,Lokad.Rules.SimpleScope.Messenger)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.SimpleScope"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="messenger">The messenger.</param>
        </member>
        <member name="M:Lokad.Rules.SimpleScope.GetMessages(System.String,System.Action{Lokad.Rules.IScope})">
            <summary>
            Gets the messages reported by the specified action to the scope.
            </summary>
            <param name="name">The name.</param>
            <param name="action">The action.</param>
            <returns>array of rule messages reported</returns>
        </member>
        <member name="T:Lokad.Rules.SimpleScope.Messenger">
            <summary>
            Delegate for relaying scope messages
            </summary>
        </member>
        <member name="T:Lokad.Threading.ParallelExtensions">
            <summary>
             Quick alternatives to PLinq with minimal overhead and simple implementations.
            </summary>
        </member>
        <member name="M:Lokad.Threading.ParallelExtensions.SelectInParallel``2(``0[],System.Func{``0,``1})">
            <summary>Executes the specified function in parallel over an array.</summary>
            <param name="input">Input array to processed in parallel.</param>
            <param name="func">The action to perform. Parameters and all the members should be immutable.</param>
            <remarks>Threads are recycled. Synchronization overhead is minimal.</remarks>
        </member>
        <member name="M:Lokad.Threading.ParallelExtensions.SelectInParallel``2(``0[],System.Func{``0,``1},System.Int32)">
            <summary>
            Executes the specified function in parallel over an array, using the provided number of threads.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="input">Input array to processed in parallel.</param>
            <param name="func">The action to perform. Parameters and all the members should be immutable.</param>
            <param name="threadCount">The thread count.</param>
            <returns></returns>
            <remarks>Threads are recycled. Synchronization overhead is minimal.</remarks>
        </member>
        <member name="P:Lokad.Threading.ParallelExtensions.DefaultThreadCount">
            <summary>Get or sets the default number of threads to be used in
            the parallel extensions. </summary>
        </member>
        <member name="T:Lokad.Threading.WaitFor`1">
            <summary>
            Helper class for invoking tasks with timeout. Overhead is 0,005 ms.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Lokad.Threading.WaitFor`1.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Threading.WaitFor`1"/> class, 
            using the specified timeout for all operations.
            </summary>
            <param name="timeout">The timeout.</param>
        </member>
        <member name="M:Lokad.Threading.WaitFor`1.Run(System.Func{`0})">
            <summary>
            Executes the spcified function within the current thread, aborting it
            if it does not complete within the specified timeout interval. 
            </summary>
            <param name="function">The function.</param>
            <returns>result of the function</returns>
            <remarks>
            The performance trick is that we do not interrupt the current
            running thread. Instead, we just create a watcher that will sleep
            until the originating thread terminates or until the timeout is
            elapsed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">if function is null</exception>
            <exception cref="T:System.TimeoutException">if the function does not finish in time </exception>
        </member>
        <member name="M:Lokad.Threading.WaitFor`1.Run(System.TimeSpan,System.Func{`0})">
            <summary>
            Executes the spcified function within the current thread, aborting it
            if it does not complete within the specified timeout interval.
            </summary>
            <param name="timeout">The timeout.</param>
            <param name="function">The function.</param>
            <returns>result of the function</returns>
            <remarks>
            The performance trick is that we do not interrupt the current
            running thread. Instead, we just create a watcher that will sleep
            until the originating thread terminates or until the timeout is
            elapsed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">if function is null</exception>
            <exception cref="T:System.TimeoutException">if the function does not finish in time </exception>
        </member>
        <member name="T:Lokad.Tuple`2">
            <summary>
            Tuple class with 2 items
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
        </member>
        <member name="M:Lokad.Tuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Pair`2"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
        </member>
        <member name="M:Lokad.Tuple`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Pair`2"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Lokad.Pair`2"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Pair`2"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Tuple`2.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Pair`2"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Pair`2"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`2.Equals(Lokad.Tuple{`0,`1})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">
            An object to compare with this object.
            </param>
        </member>
        <member name="M:Lokad.Tuple`2.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Lokad.Tuple`2.op_Equality(Lokad.Tuple{`0,`1},Lokad.Tuple{`0,`1})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Tuple`2.op_Inequality(Lokad.Tuple{`0,`1},Lokad.Tuple{`0,`1})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:Lokad.Tuple`2.Item1">
            <summary>
            Gets Item1.
            </summary>
            <value>The item1.</value>
        </member>
        <member name="P:Lokad.Tuple`2.Item2">
            <summary>
            Gets Item2.
            </summary>
            <value>The item2.</value>
        </member>
        <member name="T:Lokad.Tuple`3">
            <summary>
            Tuple class with 3 items
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
        </member>
        <member name="M:Lokad.Tuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Triple`3"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
        </member>
        <member name="M:Lokad.Tuple`3.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Triple`3"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Triple`3"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`3.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Triple`3"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Lokad.Triple`3"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Triple`3"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Tuple`3.Equals(Lokad.Tuple{`0,`1,`2})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">
            An object to compare with this object.
            </param>
        </member>
        <member name="M:Lokad.Tuple`3.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Lokad.Triple`3"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`3.op_Equality(Lokad.Tuple{`0,`1,`2},Lokad.Tuple{`0,`1,`2})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Tuple`3.op_Inequality(Lokad.Tuple{`0,`1,`2},Lokad.Tuple{`0,`1,`2})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:Lokad.Tuple`3.Item1">
            <summary>
            Gets Item1.
            </summary>
            <value>The item1.</value>
        </member>
        <member name="P:Lokad.Tuple`3.Item2">
            <summary>
            Gets Item2.
            </summary>
            <value>The item2.</value>
        </member>
        <member name="P:Lokad.Tuple`3.Item3">
            <summary>
            Gets Item3.
            </summary>
            <value>The item3.</value>
        </member>
        <member name="T:Lokad.Tuple`4">
            <summary>
            Tuple class with 4 items (also called <em>Quadruple</em>)
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
        </member>
        <member name="M:Lokad.Tuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Tuple`4"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
        </member>
        <member name="M:Lokad.Tuple`4.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`4"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`4"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`4.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`4"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Lokad.Tuple`4"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`4"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Tuple`4.Equals(Lokad.Tuple{`0,`1,`2,`3})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">
            An object to compare with this object.
            </param>
        </member>
        <member name="M:Lokad.Tuple`4.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Lokad.Tuple`4"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Lokad.Tuple`4.op_Equality(Lokad.Tuple{`0,`1,`2,`3},Lokad.Tuple{`0,`1,`2,`3})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Tuple`4.op_Inequality(Lokad.Tuple{`0,`1,`2,`3},Lokad.Tuple{`0,`1,`2,`3})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:Lokad.Tuple`4.Item1">
            <summary>
            Gets or sets the item1.
            </summary>
            <value>The item1.</value>
        </member>
        <member name="P:Lokad.Tuple`4.Item2">
            <summary>
            Gets or sets the item2.
            </summary>
            <value>The item2.</value>
        </member>
        <member name="P:Lokad.Tuple`4.Item3">
            <summary>
            Gets or sets the item3.
            </summary>
            <value>The item3.</value>
        </member>
        <member name="P:Lokad.Tuple`4.Item4">
            <summary>
            Gets or sets the item4.
            </summary>
            <value>The item4.</value>
        </member>
        <member name="T:Lokad.Tuple`5">
            <summary>
            Tuple class with 5 items (also called <em>Quintuple</em>)
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
        </member>
        <member name="M:Lokad.Tuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Tuple`4"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
        </member>
        <member name="M:Lokad.Tuple`5.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`5"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`5"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`5.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`5"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Lokad.Tuple`5"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`5"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Tuple`5.Equals(Lokad.Tuple{`0,`1,`2,`3,`4})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">
            An object to compare with this object.
            </param>
        </member>
        <member name="M:Lokad.Tuple`5.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Lokad.Tuple`5"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Lokad.Tuple`5.op_Equality(Lokad.Tuple{`0,`1,`2,`3,`4},Lokad.Tuple{`0,`1,`2,`3,`4})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Tuple`5.op_Inequality(Lokad.Tuple{`0,`1,`2,`3,`4},Lokad.Tuple{`0,`1,`2,`3,`4})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:Lokad.Tuple`5.Item1">
            <summary>
            Gets or sets the item1.
            </summary>
            <value>The item1.</value>
        </member>
        <member name="P:Lokad.Tuple`5.Item2">
            <summary>
            Gets or sets the item2.
            </summary>
            <value>The item2.</value>
        </member>
        <member name="P:Lokad.Tuple`5.Item3">
            <summary>
            Gets or sets the item3.
            </summary>
            <value>The item3.</value>
        </member>
        <member name="P:Lokad.Tuple`5.Item4">
            <summary>
            Gets or sets the item4.
            </summary>
            <value>The item4.</value>
        </member>
        <member name="P:Lokad.Tuple`5.Item5">
            <summary>
            Gets or sets the item5.
            </summary>
            <value>The item5.</value>
        </member>
        <member name="T:Lokad.Tuple`6">
            <summary>
            Tuple class with 6 items
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
        </member>
        <member name="M:Lokad.Tuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Tuple`6"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
            <param name="sixth">The sixth item.</param>
        </member>
        <member name="M:Lokad.Tuple`6.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`6"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`6"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`6.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`6"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Lokad.Tuple`6"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`6"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Tuple`6.Equals(Lokad.Tuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">
            An object to compare with this object.
            </param>
        </member>
        <member name="M:Lokad.Tuple`6.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Lokad.Tuple`6"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Lokad.Tuple`6.op_Equality(Lokad.Tuple{`0,`1,`2,`3,`4,`5},Lokad.Tuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Tuple`6.op_Inequality(Lokad.Tuple{`0,`1,`2,`3,`4,`5},Lokad.Tuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:Lokad.Tuple`6.Item1">
            <summary>
            Gets the item1.
            </summary>
            <value>The item1.</value>
        </member>
        <member name="P:Lokad.Tuple`6.Item2">
            <summary>
            Gets the item2.
            </summary>
            <value>The item2.</value>
        </member>
        <member name="P:Lokad.Tuple`6.Item3">
            <summary>
            Gets the item3.
            </summary>
            <value>The item3.</value>
        </member>
        <member name="P:Lokad.Tuple`6.Item4">
            <summary>
            Gets the item4.
            </summary>
            <value>The item4.</value>
        </member>
        <member name="P:Lokad.Tuple`6.Item5">
            <summary>
            Gets the item5.
            </summary>
            <value>The item5.</value>
        </member>
        <member name="P:Lokad.Tuple`6.Item6">
            <summary>
            Gets the item6.
            </summary>
            <value>The item6.</value>
        </member>
        <member name="T:Lokad.Tuple`7">
            <summary>
            Tuple class with 7 items
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
        </member>
        <member name="M:Lokad.Tuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Tuple`7"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
            <param name="sixth">The sixth item.</param>
            <param name="seventh">The seventh item.</param>
        </member>
        <member name="M:Lokad.Tuple`7.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`7"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Lokad.Tuple`7"/>.
            </returns>
        </member>
        <member name="M:Lokad.Tuple`7.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`7"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Lokad.Tuple`7"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Lokad.Tuple`7"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Lokad.Tuple`7.Equals(Lokad.Tuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">
            An object to compare with this object.
            </param>
        </member>
        <member name="M:Lokad.Tuple`7.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Lokad.Tuple`7"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Lokad.Tuple`7.op_Equality(Lokad.Tuple{`0,`1,`2,`3,`4,`5,`6},Lokad.Tuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Lokad.Tuple`7.op_Inequality(Lokad.Tuple{`0,`1,`2,`3,`4,`5,`6},Lokad.Tuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:Lokad.Tuple`7.Item1">
            <summary>
            Gets the item1.
            </summary>
            <value>The item1.</value>
        </member>
        <member name="P:Lokad.Tuple`7.Item2">
            <summary>
            Gets the item2.
            </summary>
            <value>The item2.</value>
        </member>
        <member name="P:Lokad.Tuple`7.Item3">
            <summary>
            Gets the item3.
            </summary>
            <value>The item3.</value>
        </member>
        <member name="P:Lokad.Tuple`7.Item4">
            <summary>
            Gets the item4.
            </summary>
            <value>The item4.</value>
        </member>
        <member name="P:Lokad.Tuple`7.Item5">
            <summary>
            Gets the item5.
            </summary>
            <value>The item5.</value>
        </member>
        <member name="P:Lokad.Tuple`7.Item6">
            <summary>
            Gets the item6.
            </summary>
            <value>The item6.</value>
        </member>
        <member name="P:Lokad.Tuple`7.Item7">
            <summary>
            Gets the item7.
            </summary>
            <value>The item7.</value>
        </member>
        <member name="T:Lokad.ExtendTuple">
            <summary>
            Helper extensions for tuples
            </summary>
        </member>
        <member name="M:Lokad.ExtendTuple.Append``3(Lokad.Tuple{``0,``1},``2)">
            <summary>
            Appends the specified <paramref name="item"/> to the <paramref name="tuple"/>.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <param name="tuple">The tuple to append to.</param>
            <param name="item">The item to append.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.ExtendTuple.Append``4(Lokad.Tuple{``0,``1,``2},``3)">
            <summary>
            Appends the specified <paramref name="item"/> to the <paramref name="tuple"/>.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <param name="tuple">The tuple to append to.</param>
            <param name="item">The item to append.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.ExtendTuple.Append``5(Lokad.Tuple{``0,``1,``2,``3},``4)">
            <summary>
            Appends the specified <paramref name="item"/> to the <paramref name="tuple"/>.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <param name="tuple">The tuple to append to.</param>
            <param name="item">The item to append.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.ExtendTuple.Append``6(Lokad.Tuple{``0,``1,``2,``3,``4},``5)">
            <summary>
            Appends the specified <paramref name="item"/> to the <paramref name="tuple"/>.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <param name="tuple">The tuple to append to.</param>
            <param name="item">The item to append.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.ExtendTuple.Append``7(Lokad.Tuple{``0,``1,``2,``3,``4,``5},``6)">
            <summary>
            Appends the specified <paramref name="item"/> to the <paramref name="tuple"/>.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <param name="tuple">The tuple to append to.</param>
            <param name="item">The item to append.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.ExtendTuple.AddTuple``2(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1}},``0,``1)">
            <summary> Shortcut to create and add tuple to the collection </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
        </member>
        <member name="M:Lokad.ExtendTuple.AddTuple``2(System.Collections.Generic.ICollection{Lokad.Pair{``0,``1}},``0,``1)">
            <summary> Shortcut to create and add tuple to the collection </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
        </member>
        <member name="M:Lokad.ExtendTuple.AddTuple``3(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1,``2}},``0,``1,``2)">
            <summary> Shortcut to create and add tuple to the collection </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
        </member>
        <member name="M:Lokad.ExtendTuple.AddTuple``4(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1,``2,``3}},``0,``1,``2,``3)">
            <summary> Shortcut to create and add tuple to the collection </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
        </member>
        <member name="M:Lokad.ExtendTuple.AddTuple``5(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1,``2,``3,``4}},``0,``1,``2,``3,``4)">
            <summary> Shortcut to create and add tuple to the collection </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <param name="collection">The collection to add to.</param>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
        </member>
        <member name="T:Lokad.ArrayUtil">
            <summary>
            Utility class to manipulate arrays
            </summary>
        </member>
        <member name="M:Lokad.ArrayUtil.IsNullOrEmpty(System.Array)">
            <summary>
            Returns <em>True</em> if the provided array is null or empty
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="F:Lokad.ArrayUtil.EmptyGuid">
            <summary>
            Empty array of <see cref="T:System.Guid"/>
            </summary>
        </member>
        <member name="F:Lokad.ArrayUtil.EmptyInt32">
            <summary>
            Empty array of <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:Lokad.ArrayUtil.EmptyString">
            <summary>
            Empty array of <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Lokad.ArrayUtil.Empty``1">
            <summary>
            Returns empty array instance
            </summary>
            <typeparam name="T">type of the item for the array</typeparam>
            <returns>empty array singleton</returns>
        </member>
        <member name="T:Lokad.AssemblyUtil">
            <summary>
            Helper class for the managing .NET assemblies
            </summary>
        </member>
        <member name="M:Lokad.AssemblyUtil.GetAssemblyConfiguration">
            <summary>
            Retrieves value of the <see cref="T:System.Reflection.AssemblyConfigurationAttribute"/> for the current assembly
            </summary>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">When the attribute is missing</exception>
        </member>
        <member name="M:Lokad.AssemblyUtil.GetAssemblyDescription">
            <summary>
            If <see cref="T:System.Reflection.AssemblyDescriptionAttribute"/> is present in the calling assembly, 
            then its value is retrieved. <see cref="F:System.String.Empty"/> is returned otherwise.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lokad.Diagnostics.ExecutionCounters">
            <summary>
            In-memory thread-safe collection of <see cref="T:Lokad.Diagnostics.ExecutionCounter"/>
            </summary>
        </member>
        <member name="F:Lokad.Diagnostics.ExecutionCounters.Default">
            <summary>
            Default instance of this counter
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounters.RegisterRange(System.Collections.Generic.IEnumerable{Lokad.Diagnostics.ExecutionCounter})">
            <summary>
            Registers the execution counters within this collection.
            </summary>
            <param name="counters">The counters.</param>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounters.ToList">
            <summary>
            Retrieves statistics for all exception counters in this collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounters.ResetAll">
            <summary>
            Resets all counters.
            </summary>
        </member>
        <member name="T:Lokad.ExtendDouble">
            <summary>
            Some helper shortcuts for the <see cref="T:System.Double"/>
            </summary>
        </member>
        <member name="M:Lokad.ExtendDouble.Round(System.Double,System.Int32)">
            <summary>
            Rounds the specified double with the provided number 
            of fractional digits.
            </summary>
            <param name="value">The value to round.</param>
            <param name="digits">The digits.</param>
            <returns>rounded value</returns>
        </member>
        <member name="M:Lokad.ExtendDouble.Minutes(System.Double)">
            <summary>Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of minutes.</summary>
            <param name="minutes">number of minutes</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
            <example>3D.Minutes()</example>
        </member>
        <member name="M:Lokad.ExtendDouble.Hours(System.Double)">
            <summary>Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of hours.</summary>
            <param name="hours">number of hours</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
            <example>3D.Hours()</example>
        </member>
        <member name="M:Lokad.ExtendDouble.Seconds(System.Double)">
            <summary>Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of seconds.</summary>
            <param name="seconds">number of seconds</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
            <example>2D.Seconds()</example>
        </member>
        <member name="M:Lokad.ExtendDouble.Milliseconds(System.Double)">
            <summary>Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of milliseconds.</summary>
            <param name="milliseconds">milliseconds for this timespan</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
        </member>
        <member name="M:Lokad.ExtendDouble.Days(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of days.
            </summary>
            <param name="days">Number of days, accurate to the milliseconds.</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
        </member>
        <member name="T:Lokad.Errors">
            <summary>
            Helper class for generating exceptions
            </summary>
        </member>
        <member name="M:Lokad.Errors.KeyInvalid">
            <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException"/>
            </summary>
            <returns>new exception instance</returns>
        </member>
        <member name="M:Lokad.Errors.KeyInvalid(System.Object)">
            <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException"/>
            </summary>
            <param name="value">The value.</param>
            <returns>new exception instance</returns>
        </member>
        <member name="M:Lokad.Errors.Resolution(System.Type,System.Object,System.Exception)">
            <summary>
            Creates new instance of the <see cref="T:Lokad.ResolutionException"/>
            </summary>
            <param name="valueType">Type of the service.</param>
            <param name="key">The service key.</param>
            <param name="inner">The inner.</param>
            <returns>new exception instance</returns>
        </member>
        <member name="M:Lokad.Errors.Resolution(System.Type,System.Exception)">
            <summary>
            Creates new instance of the <see cref="T:Lokad.ResolutionException"/>
            </summary>
            <param name="valueType">Type of the service.</param>
            <param name="inner">The inner.</param>
            <returns>new exception instance</returns>
        </member>
        <member name="M:Lokad.Errors.KeyInvalid(System.Object,System.Exception)">
            <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException"/>
            </summary>
            <param name="value">The value.</param>
            <param name="inner">The inner.</param>
            <returns>new exception instance</returns>
        </member>
        <member name="M:Lokad.Errors.InvalidOperation(System.String,System.Object[])">
            <summary>
            Creates new instance of <see cref="T:System.InvalidOperationException"/>
            </summary>
            <param name="message">The message.</param>
            <param name="args">The arguments of the format string.</param>
            <returns>new exception instance</returns>
        </member>
        <member name="T:Lokad.ExtendIDictionary">
            <summary>
            Extensions for <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Lokad.ExtendIDictionary.AsProvider``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Wraps the dictionary with the read-only provider instance
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="self">The dictionary.</param>
            <returns>provider instance that wraps the dictionary</returns>
        </member>
        <member name="M:Lokad.ExtendIDictionary.AsProvider``1(System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>
            Wraps the provider with the read-only provider instance
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="self">The dictionary.</param>
            <returns>provider instance that wraps the dictionary</returns>
        </member>
        <member name="M:Lokad.ExtendIDictionary.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Returns <paramref name="defaultValue"/> if the given <paramref name="key"/>
            is not present within the dictionary
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="self">The dictionary.</param>
            <param name="key">The key to look for.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value matching <paramref name="key"/> or <paramref name="defaultValue"/> if none is found</returns>
        </member>
        <member name="M:Lokad.ExtendIDictionary.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets the value from the <paramref name="dictionary"/> in form of the <see cref="T:Lokad.Maybe`1"/>.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key.</param>
            <returns>value from the dictionary</returns>
        </member>
        <member name="T:Lokad.KeyInvalidException">
            <summary>
            This exception is thrown when the key is not valid (i.e.: not found)
            </summary>
            <remarks> TODO: add proper implementation.</remarks>
        </member>
        <member name="M:Lokad.KeyInvalidException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException"/> class.
            </summary>
        </member>
        <member name="M:Lokad.KeyInvalidException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Lokad.KeyInvalidException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Lokad.KeyInvalidException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:Lokad.DisposableAction">
            <summary>
            Class that allows action to be executed, when it is disposed
            </summary>
        </member>
        <member name="M:Lokad.DisposableAction.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.DisposableAction"/> class.
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="M:Lokad.DisposableAction.Dispose">
            <summary>
            Executes the action
            </summary>
        </member>
        <member name="T:Lokad.BufferUtil">
            <summary>
            Helper utilities for working with byte buffers
            </summary>
        </member>
        <member name="M:Lokad.BufferUtil.CalculateSimpleHashCode(System.Byte[])">
            <summary>
            Calculates simple hash code
            </summary>
            <param name="bytes">The bytes to hash.</param>
            <returns>hash for the buffer</returns>
            <exception cref="T:System.ArgumentNullException">if bytes are null</exception>
        </member>
        <member name="T:Lokad.DebugUtil">
            <summary>
            Helper utility for debugging
            </summary>
        </member>
        <member name="M:Lokad.DebugUtil.SaveTo(System.Object,System.String)">
            <summary>
            Saves the object graph to the specified path.
            </summary>
            <param name="graph">The graph.</param>
            <param name="path">The path to save to.</param>
        </member>
        <member name="M:Lokad.DebugUtil.LoadFrom(System.String)">
            <summary>
            Loads the graph from the specified path.
            </summary>
            <param name="path">The path to load from.</param>
            <returns>graph loaded from the specified path</returns>
        </member>
        <member name="M:Lokad.DebugUtil.LoadFrom``1(System.String)">
            <summary>
            Loads the graph from the specified path.
            </summary>
            <typeparam name="TGraph">The type of the item.</typeparam>
            <param name="path">The path to load from.</param>
            <returns>graph loaded from the specified path</returns>
        </member>
        <member name="T:Lokad.EnumUtil">
            <summary>
            Enum helper class from xLim
            </summary>
        </member>
        <member name="M:Lokad.EnumUtil.Parse``1(System.String)">
            <summary>
            Parses the specified string into the <typeparamref name="TEnum"/>, ignoring the case
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The value.</param>
            <returns>Parsed enum</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is null</exception>
        </member>
        <member name="M:Lokad.EnumUtil.Parse``1(System.String,System.Boolean)">
            <summary>
            Parses the specified string into the <typeparamref name="TEnum"/>, ignoring the case
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The value.</param>
            <param name="ignoreCase">if set to <c>true</c> [ignore case].</param>
            <returns>Parsed enum</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is null</exception>
        </member>
        <member name="M:Lokad.EnumUtil.ToIdentifier``1(``0)">
            <summary>
            Unwraps the enum by creating a string usable for identifiers and resource lookups.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="enumItem">The enum item.</param>
            <returns>a string usable for identifiers and resource lookups</returns>
        </member>
        <member name="M:Lokad.EnumUtil.GetValues``1">
            <summary>
            Gets the values associated with the specified enum.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <returns>array instance of the enum values</returns>
        </member>
        <member name="M:Lokad.EnumUtil.GetValuesWithoutDefault``1">
            <summary>
            Gets the values associated with the specified enum, 
            with the exception of the default value
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <returns>array instance of the enum values</returns>
        </member>
        <member name="T:Lokad.EnumUtil`2">
            <summary>
            Ensures that enums can be converted between each other
            </summary>
            <typeparam name="TFromEnum">The type of from enum.</typeparam>
            <typeparam name="TToEnum">The type of to enum.</typeparam>
        </member>
        <member name="T:Lokad.EnumUtil`1">
            <summary>
            Strongly-typed enumeration util
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
        </member>
        <member name="F:Lokad.EnumUtil`1.Values">
            <summary>
            Values of the <typeparamref name="TEnum"/>
            </summary>
        </member>
        <member name="F:Lokad.EnumUtil`1.ValuesWithoutDefault">
            <summary>
            Values of the <typeparamref name="TEnum"/> without the default value.
            </summary>
        </member>
        <member name="M:Lokad.EnumUtil`1.ConvertSafelyFrom``1(``0)">
            <summary>
            Converts the safely from.
            </summary>
            <typeparam name="TSourceEnum">The type of the source enum.</typeparam>
            <param name="enum">The @enum to convert from.</param>
            <returns>converted enum</returns>
            <exception cref="T:System.ArgumentException"> when conversion is not possible</exception>
        </member>
        <member name="T:Lokad.ExtendInt32">
            <summary> Extensions to the <see cref="T:System.Int32"/> </summary>
        </member>
        <member name="M:Lokad.ExtendInt32.Kb(System.Int32)">
            <summary>
            Returns kilobytes
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Lokad.ExtendInt32.Mb(System.Int32)">
            <summary>
            Returns megabytes
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Lokad.ExtendInt32.Minutes(System.Int32)">
            <summary>Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of minutes.</summary>
            <param name="minutes">number of minutes</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
            <example>3.Minutes()</example>
        </member>
        <member name="M:Lokad.ExtendInt32.Seconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of seconds.
            </summary>
            <param name="seconds">number of seconds</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
            <example>2.Seconds()</example>
        </member>
        <member name="M:Lokad.ExtendInt32.Milliseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of milliseconds.
            </summary>
            <param name="milliseconds">milliseconds for this timespan</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
        </member>
        <member name="M:Lokad.ExtendInt32.Days(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of days.
            </summary>
            <param name="days">Number of days.</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
        </member>
        <member name="M:Lokad.ExtendInt32.Hours(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents a specified number of hours.
            </summary>
            <param name="hours">Number of hours.</param>
            <returns>A <see cref="T:System.TimeSpan"/> that represents a value.</returns>
        </member>
        <member name="T:Lokad.IProvider`2">
            <summary>
            Interface that abstracts away providers
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <remarks>
            things like IDataCache (from the Database layers) or IResolver (from the IoC layers) 
            are just samples of this interface
            </remarks>
        </member>
        <member name="M:Lokad.IProvider`2.Get(`0)">
            <summary>
            Retrieves <typeparamref name="TValue"/> given the
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:Lokad.ResolutionException">when the key can not be resolved</exception>
        </member>
        <member name="T:Lokad.IResolver">
            <summary>
            Generic resolution interface for the applications, 
            where proper infrastructure could not be setup
            </summary>
            <remarks>There are no Generic resolution methods 
            (like Resolve(Type service)), for the purpose of enforcing 
            explicit resolution logics </remarks>
        </member>
        <member name="M:Lokad.IResolver.Get``1">
            <summary>
            Resolves this instance.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns>requested instance of <typeparamref name="TService"/></returns>
            <exception cref="T:Lokad.ResolutionException">if there is some resolution problem</exception>
        </member>
        <member name="M:Lokad.IResolver.Get``1(System.String)">
            <summary>
            Resolves the specified service type.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="name">The name.</param>
            <returns>requested instance of <typeparamref name="TService"/></returns>
            <exception cref="T:Lokad.ResolutionException">if there is resolution problem</exception>
        </member>
        <member name="T:Lokad.Lambda`1">
            <summary>
            Helper class for creating lambda expressions that return
            anonymous types
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
        </member>
        <member name="M:Lokad.Lambda`1.Func``1(System.Func{`0,``0})">
            <summary>
            Returns the provided function.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="func">The func.</param>
            <returns>returns the same function instance</returns>
        </member>
        <member name="T:Lokad.Lambda">
            <summary>
            Helper class for creating lambda expressions that return
            anonymous types
            </summary>
        </member>
        <member name="M:Lokad.Lambda.Func``1(System.Func{``0})">
            <summary>
            Returns the provided function
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="func">The function.</param>
            <returns>returns same function instance</returns>
        </member>
        <member name="M:Lokad.Lambda.Action``1(System.Action{``0})">
            <summary>
            Returns the provided action
            </summary>
            <param name="action">The action.</param>
            <returns>returns same action instance</returns>
        </member>
        <member name="T:Lokad.NamedProvider`1">
            <summary>
            This class provides way to create providers out of lambda shortcuts
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Lokad.INamedProvider`1">
            <summary>
            Shortcut interface for <see cref="T:Lokad.IProvider`2"/> that uses <see cref="T:System.String"/> as the key.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Lokad.NamedProvider`1.#ctor(System.Func{System.String,`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.NamedProvider`1"/> class.
            </summary>
            <param name="resolver">The resolver.</param>
        </member>
        <member name="M:Lokad.NamedProvider`1.Get(System.String)">
            <summary>
            Retrieves <typeparamref name="T"/> given the <paramref name="key"/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:Lokad.ResolutionException">when the key cannot be resolved</exception>
        </member>
        <member name="T:Lokad.NamedProvider">
            <summary>
            Shortcuts for <see cref="T:Lokad.NamedProvider`1"/>
            </summary>
        </member>
        <member name="M:Lokad.NamedProvider.For``1(System.Func{System.String,``0})">
            <summary>
            Creates new instance of the <see cref="T:Lokad.INamedProvider`1"/> out of
            the provider function (shortcut syntax)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="providerFunction">The provider function.</param>
            <returns></returns>
        </member>
        <member name="T:Lokad.Provider`2">
            <summary>
            This class provides short-cut for creating providers
            out of lambda expressions.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:Lokad.Provider`2.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Provider`2"/> class.
            </summary>
            <param name="resolver">The resolver.</param>
            <exception cref="T:System.ArgumentNullException">When 
            <paramref name="resolver"/> is null</exception>
        </member>
        <member name="M:Lokad.Provider`2.Get(`0)">
            <summary>
            Retrieves <typeparamref name="TValue"/> given the
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:Lokad.ResolutionException">when the key is invalid for
            the provider</exception>
        </member>
        <member name="T:Lokad.Provider`1">
            <summary>
            Helper class that simplifies creation of <see cref="T:Lokad.Provider`2"/>
            </summary>
            <typeparam name="TKey">type of the Key items</typeparam>
        </member>
        <member name="M:Lokad.Provider`1.For``1(System.Func{`0,``0})">
            <summary>
            Creates the provider, letting compiler to figure out
            the value type. This allows to use anonymous types locally as well
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="func">The function that is the provider.</param>
            <returns>new provider instance</returns>
        </member>
        <member name="T:Lokad.Quad`4">
            <summary>
            Tuple class with 4 items (also called <em>Quadruple</em>)
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
        </member>
        <member name="M:Lokad.Quad`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quad`4"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
        </member>
        <member name="T:Lokad.Range">
            <summary>
            Helper class with shortcut methods for managing enumerations.
            Useful for inlining object generation in tests
            </summary>
        </member>
        <member name="M:Lokad.Range.Empty``1">
            <summary> Returns empty enumerator </summary>
            <typeparam name="T">type of the item to enumerate</typeparam>
            <returns>singleton instance of the empty enumerator</returns>
        </member>
        <member name="M:Lokad.Range.Create(System.Int32)">
            <summary>
            returns enumeration from 0 with <paramref name="count"/> numbers
            </summary>
            <param name="count">Number of items to create</param>
            <returns>enumerable</returns>
        </member>
        <member name="M:Lokad.Range.Create(System.Int32,System.Int32)">
            <summary>
            Creates sequence of the integral numbers within the specified range
            </summary>
            <param name="start">The value of the first integer in sequence.</param>
            <param name="count">The number of values in the sequence.</param>
            <returns>sequence of the integral numbers within the specified range</returns>
        </member>
        <member name="M:Lokad.Range.Repeat``1(``0,System.Int32)">
            <summary>
            Creates sequence that consists of a repeated value.
            </summary>
            <typeparam name="TResult">The type of the value to repeat.</typeparam>
            <param name="item">The value to repeat.</param>
            <param name="count">The number of times to repeat.</param>
            <returns>sequence that consists of a repeated value</returns>
        </member>
        <member name="M:Lokad.Range.Create``1(System.Func{System.Int32,``0})">
            <summary>
            Creates the generator to iterate from 1 to <see cref="F:System.Int32.MaxValue"/>.
            </summary>
            <typeparam name="T">type of the item to generate</typeparam>
            <param name="generator">The generator.</param>
            <returns>new enumerator</returns>
        </member>
        <member name="M:Lokad.Range.Create``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Creates the enumerable using the provided generator.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="count">The count.</param>
            <param name="generator">The generator.</param>
            <returns>enumerable instance</returns>
        </member>
        <member name="M:Lokad.Range.Create``1(System.Int32,System.Func{``0})">
            <summary>
            Creates the enumerable using the provided generator.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="count">The count.</param>
            <param name="generator">The generator.</param>
            <returns>enumerable instance</returns>
        </member>
        <member name="M:Lokad.Range.Array``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Creates the array populated with the provided generator
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="count">The count.</param>
            <param name="generator">The generator.</param>
            <returns>array</returns>
        </member>
        <member name="M:Lokad.Range.Array(System.Int32)">
            <summary>
            Creates the array of integers
            </summary>
            <param name="count">The count.</param>
            <returns></returns>
        </member>
        <member name="T:Lokad.ResolutionException">
            <summary>
            Exception that is thrown by <see cref="T:Lokad.IResolver"/> or <see cref="T:Lokad.IProvider`2"/>
            </summary>
        </member>
        <member name="M:Lokad.ResolutionException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException"/> class.
            </summary>
        </member>
        <member name="M:Lokad.ResolutionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException"/> class.
            </summary>
            <param name="message">The message related to this exception.</param>
        </member>
        <member name="M:Lokad.ResolutionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException"/> class.
            </summary>
            <param name="message">The message related to this exception.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Lokad.ResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:Lokad.Resolver">
            <summary>
            Implementation of the <see cref="T:Lokad.IResolver"/> that uses delegates
            to wire up the resolution logics and wraps all exceptions with the
            <see cref="T:Lokad.ResolutionException"/>
            </summary>
        </member>
        <member name="M:Lokad.Resolver.#ctor(System.Func{System.Type,System.Object},System.Func{System.Type,System.String,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Resolver"/> class.
            </summary>
            <param name="resolver">The resolver.</param>
            <param name="namedResolver">The named resolver.</param>
        </member>
        <member name="M:Lokad.Resolver.Get``1">
            <summary>
            Resolves this instance.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns>
            requested instance of <typeparamref name="TService"/>
            </returns>
            <exception cref="T:Lokad.ResolutionException">if there is some resolution problem</exception>
        </member>
        <member name="M:Lokad.Resolver.Get``1(System.String)">
            <summary>
            Resolves the specified service type.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="name">The name.</param>
            <returns>
            requested instance of <typeparamref name="TService"/>
            </returns>
            <exception cref="T:Lokad.ResolutionException">if there is resolution problem</exception>
        </member>
        <member name="T:Lokad.FormatUtil">
            <summary>
            Pretty format utils
            </summary>
        </member>
        <member name="M:Lokad.FormatUtil.SizeInBytes(System.Int64)">
            <summary>
            Formats the size in bytes to a pretty string.
            </summary>
            <param name="sizeInBytes">The size in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.FormatUtil.TimeOffsetUtc(System.DateTime)">
            <summary>
            Displays time passed since (or remaining before) some event expressed in UTC, displaying it as '<em>5 days ago</em>'.
            </summary>
            <param name="dateInUtc">The date in UTC.</param>
            <returns>formatted event</returns>
        </member>
        <member name="M:Lokad.FormatUtil.TimeOffset(System.DateTime)">
            <summary>
            Displays time passed since some event expressed, displaying it as '<em>5 days ago</em>'.
            </summary>
            <param name="localTime">The local time.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.FormatUtil.TimeSpan(System.TimeSpan)">
            <summary>
            Formats time span nicely
            </summary>
            <param name="offset">The offset.</param>
            <returns>formatted string</returns>
        </member>
        <member name="T:Lokad.ResourceUtil`1">
            <summary>
            Simple helper class to replace common "DataMother" helper
            used in tests.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lokad.ResourceUtil`1.GetStream(System.String)">
            <summary>
            Gets the stream for the associated resource from the <typeparamref name="T"/>
            namespace.
            </summary>
            <seealso cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)"/>
            <param name="name">The name of the resource.</param>
            <returns></returns>
        </member>
        <member name="T:Lokad.Data.SqlClient.SqlServerGuidComparer">
            <summary>
            This class compares two guids according to the SQL server ordering rules.
            </summary>
        </member>
        <member name="F:Lokad.Data.SqlClient.SqlServerGuidComparer.Instance">
            <summary>
            Singleton instance of the <see cref="T:Lokad.Data.SqlClient.SqlServerGuidComparer"/>
            </summary>
        </member>
        <member name="M:Lokad.Data.SqlClient.SqlServerGuidComparer.Compare(System.Guid,System.Guid)">
            <summary>
            Compares two guids and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first guid to compare.</param>
            <param name="y">The second guid to compare.</param>
            <returns>
            Value indicating relation between x and y
            </returns>
        </member>
        <member name="T:Lokad.Result">
            <summary> Helper class for creating <see cref="T:Lokad.Result`1"/> instances </summary>
        </member>
        <member name="M:Lokad.Result.CreateSuccess``1(``0)">
            <summary> Creates success result </summary>
            <typeparam name="TValue">The type of the result.</typeparam>
            <param name="value">The item.</param>
            <returns>new result instance</returns>
            <seealso cref="M:Lokad.Result`1.CreateSuccess(`0)"/>
        </member>
        <member name="M:Lokad.Result.Success``1(``0)">
            <summary> Creates success result </summary>
            <typeparam name="TValue">The type of the result.</typeparam>
            <param name="value">The item.</param>
            <returns>new result instance</returns>
            <seealso cref="M:Lokad.Result`1.CreateSuccess(`0)"/>
        </member>
        <member name="T:Lokad.Rules.DoubleIs">
            <summary>
            Rules for the <see cref="T:System.Double"/>
            </summary>
        </member>
        <member name="M:Lokad.Rules.DoubleIs.Valid(System.Double,Lokad.Rules.IScope)">
            <summary>
            Checks if the specified double is valid.
            </summary>
            <param name="value">The value.</param>
            <param name="scope">The scope.</param>
        </member>
        <member name="T:Lokad.Rules.RuleMessages">
            <summary>
            Collection of messages with the associated highest level
            </summary>
        </member>
        <member name="P:Lokad.Rules.RuleMessages.Level">
            <summary>
            The highest level within the collection
            </summary>
            <value>The level.</value>
        </member>
        <member name="P:Lokad.Rules.RuleMessages.IsError">
            <summary>
            Gets a value indicating whether this instance has a message 
            of  <see cref="F:Lokad.Rules.RuleLevel.Error"/> or higher.
            </summary>
            <value><c>true</c> if this instance has message of 
            <see cref="F:Lokad.Rules.RuleLevel.Error"/> or higher ; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Lokad.Rules.RuleMessages.IsWarn">
            <summary>
            Gets a value indicating whether this instance has a message 
            of <see cref="F:Lokad.Rules.RuleLevel.Warn"/> or higher.
            </summary>
            <value><c>true</c> if this instance has message of 
            <see cref="F:Lokad.Rules.RuleLevel.Warn"/> or higher ; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Lokad.Rules.RuleMessages.IsSuccess">
            <summary>
            Gets a value indicating whether this instance does not have any messages
            of <see cref="F:Lokad.Rules.RuleLevel.Warn"/> or higher
            </summary>
            <value>
            	<c>true</c> if this instance does not have any messages
            of <see cref="F:Lokad.Rules.RuleLevel.Warn"/> or higher; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Lokad.Rules.Rule`1">
            <summary>
             Typed delegate for holding the validation logics
            </summary>
            <param name="obj">Object to validate</param>
            <param name="scope">Scope that will hold all validation results</param>
            <typeparam name="T">type of the item to validate</typeparam>
        </member>
        <member name="T:Lokad.Rules.RuleException">
            <summary>
            Exception that is thrown when some validation error is encountered
            </summary>
            <remarks>
            TODO: add proper implementation
            </remarks>
        </member>
        <member name="M:Lokad.Rules.RuleException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="reference">The reference.</param>
        </member>
        <member name="M:Lokad.Rules.RuleException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Lokad.Rules.RuleException.#ctor(System.Collections.Generic.IEnumerable{Lokad.Rules.RuleMessage})">
            <summary> Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException"/> class. </summary>
            <param name="messages">The messages.</param>
        </member>
        <member name="M:Lokad.Rules.RuleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:Lokad.Rules.DateIs">
            <summary> Rules for the <see cref="T:System.DateTime"/> </summary>
        </member>
        <member name="M:Lokad.Rules.DateIs.SqlCompatible(System.DateTime,Lokad.Rules.IScope)">
            <summary>
            Verifies that it is ok to send this date directly into the MS SQL DB
            </summary>
            <param name="dateTime">The dateTime to validate.</param>
            <param name="scope">validation scope</param>
        </member>
        <member name="T:Lokad.Rules.Is">
            <summary>
            Generic rules 
            </summary>
        </member>
        <member name="M:Lokad.Rules.Is.NotEqual``1(System.IEquatable{``0})">
            <summary>
            Composes the validator ensuring that the provided value does not equal to <paramref name="item"/>
            </summary>
            <typeparam name="T">type of the item to compare</typeparam>
            <param name="item">The item.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.Equal``1(System.IEquatable{``0})">
            <summary>
            Composes the validator ensuring that the provided value equals to <paramref name="item"/>
            </summary>
            <typeparam name="T">type of the item to compare</typeparam>
            <param name="item">The item.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.Value``1(``0)">
            <summary>
            Composes the validator ensuring that the provided value equals to <paramref name="item"/>
            </summary>
            <typeparam name="T">type of the item to compare</typeparam>
            <param name="item">The item.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.SameAs``1(``0)">
            <summary>
            Composes the validator ensuring that the provided object is same as <paramref name="item"/>
            </summary>
            <typeparam name="T">type of the item to compare</typeparam>
            <param name="item">The item.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.NotDefault``1(``0,Lokad.Rules.IScope)">
            <summary>
            Returns error if the provided value type has default value
            </summary>
            <typeparam name="T">value type to check</typeparam>
            <param name="item">The item.</param>
            <param name="scope">The scope.</param>
        </member>
        <member name="M:Lokad.Rules.Is.Default``1(``0,Lokad.Rules.IScope)">
            <summary>
            Returns error if provided value type has been initialized
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item">The item.</param>
            <param name="scope">The scope.</param>
        </member>
        <member name="M:Lokad.Rules.Is.Within``1(System.IComparable{``0},System.IComparable{``0})">
            <summary>
            Composes the range validator that ensures that the supplied value belongs
            to the interval from <paramref name="minValue"/> to <paramref name="maxValue"/>
            (inclusive).
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="minValue">The min value.</param>
            <param name="maxValue">The max value.</param>
            <returns>new validator instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.Between``1(System.IComparable{``0},System.IComparable{``0})">
            <summary>
            Composes the range validator that ensures that the supplied value belongs
            to the interval between <paramref name="lowerBound"/> and <paramref name="upperBound"/>
            (exclusive)
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.GreaterThan``1(System.IComparable{``0})">
            <summary>
            Creates the rule to ensure that the validated value is greater than
            the specified <paramref name="comparable"/>
            </summary>
            <typeparam name="T">type of the item to run rule against</typeparam>
            <param name="comparable">The comparable.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.AtLeast``1(System.IComparable{``0})">
            <summary>
            Creates the rule to ensure that the validated value is greater than
            or equal to the specified <paramref name="comparable"/>
            </summary>
            <typeparam name="T">type of the item to run rule against</typeparam>
            <param name="comparable">The comparable.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.AtMost``1(System.IComparable{``0})">
            <summary>
            Creates the rule to ensure that the validated value is less than
            or equal to the specified <paramref name="comparable"/>
            </summary>
            <typeparam name="T">type of the item to run rule against</typeparam>
            <param name="comparable">The comparable.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.LessThan``1(System.IComparable{``0})">
            <summary>
            Creates the rule to ensure that the validated value is less than
            the specified <paramref name="comparable"/>
            </summary>
            <typeparam name="T">type of the item to run rule against</typeparam>
            <param name="comparable">The comparable.</param>
            <returns>new rule instance</returns>
        </member>
        <member name="M:Lokad.Rules.Is.True``1(System.Linq.Expressions.Expression{System.Predicate{``0}})">
            <summary> 
            <para>Compiles the rule out of the specified expression.</para> 
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="expression">The expression.</param>
            <returns>compiled rule instance</returns>
        </member>
        <member name="T:Lokad.Rules.RuleLevel">
            <summary>
            Levels leveraged by the <see cref="T:Lokad.Rules.Rule`1"/> implementations
            </summary>
        </member>
        <member name="F:Lokad.Rules.RuleLevel.None">
            <summary> Default value for the purposes of good citizenship </summary>
        </member>
        <member name="F:Lokad.Rules.RuleLevel.Warn">
            <summary> The rule raises a warning </summary>
        </member>
        <member name="F:Lokad.Rules.RuleLevel.Error">
            <summary> The rule raises an error </summary>
        </member>
        <member name="T:Lokad.Rules.RuleMessage">
            <summary> Rule message </summary>
        </member>
        <member name="M:Lokad.Rules.RuleMessage.#ctor(System.String,Lokad.Rules.RuleLevel,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleMessage"/> class.
            </summary>
            <param name="path">The path.</param>
            <param name="level">The level.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Lokad.Rules.RuleMessage.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:Lokad.Rules.RuleMessage.Path">
            <summary>
            Gets the object path for the current message.
            </summary>
            <value>The path object path.</value>
        </member>
        <member name="P:Lokad.Rules.RuleMessage.Level">
            <summary>
            Gets the <see cref="T:Lokad.Rules.RuleLevel"/> associated with this message.
            </summary>
            <value>The level.</value>
        </member>
        <member name="P:Lokad.Rules.RuleMessage.Message">
            <summary>
            Gets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="T:Lokad.Rules.StringIs">
            <summary>
            Common string rules
            </summary>
        </member>
        <member name="F:Lokad.Rules.StringIs.EmailRegex">
            <summary>
            Originally http://fightingforalostcause.net/misc/2006/compare-email-regex.php,
            but modified to have less negative results 
            </summary> 
        </member>
        <member name="M:Lokad.Rules.StringIs.ValidEmail(System.String,Lokad.Rules.IScope)">
            <summary>
            Determines whether the string is valid email address
            </summary>
            <param name="email">string to validate</param>
            <param name="scope">validation scope.</param>
        </member>
        <member name="M:Lokad.Rules.StringIs.ValidServerConnection(System.String,Lokad.Rules.IScope)">
            <summary>
            Determines whether the string is valid server connection (with optional port)
            </summary>
            <param name="host">The host name to validate.</param>
            <param name="scope">The validation scope.</param>
        </member>
        <member name="M:Lokad.Rules.StringIs.Limited(System.Int32,System.Int32)">
            <summary>
            Composes the string validator ensuring string length is within the supplied rangs
            </summary>
            <param name="minLength">Min string length.</param>
            <param name="maxLength">Max string length.</param>
            <returns>new validator instance</returns>
        </member>
        <member name="M:Lokad.Rules.StringIs.Limited(System.Int32)">
            <summary>
            Composes the string validator ensuring string length is shorter than
            <paramref name="maxLength"/>
            </summary>
            <param name="maxLength">Max string length.</param>
            <returns>new validator instance</returns>
        </member>
        <member name="F:Lokad.Rules.StringIs.NotEmpty">
            <summary>
            Reports error if the associated string is empty
            </summary>
        </member>
        <member name="M:Lokad.Rules.StringIs.Without(System.Char[])">
            <summary>
            String validator that ensures absence of any illegal characters
            </summary>
            <param name="illegalCharacters">The illegal characters.</param>
            <returns>new validator instance</returns>
        </member>
        <member name="F:Lokad.Rules.StringIs.ValidForXmlSerialization">
            <summary>
            String validator that detects possible issues 
            for passing strings through the ASP.NET Web services
            </summary>
        </member>
        <member name="F:Lokad.Rules.StringIs.WithoutLeadingWhiteSpace">
            <summary> String validator checking for presence of 
            white-space characters in the beginning of string </summary>
        </member>
        <member name="F:Lokad.Rules.StringIs.WithoutTrailingWhiteSpace">
            <summary> String validator checking for presence of 
            white-space characters in the end of string </summary>
        </member>
        <member name="F:Lokad.Rules.StringIs.WithoutUppercase">
            <summary> String validator checking for presence of uppercase 
            characters </summary>
        </member>
        <member name="T:Lokad.Rules.Scope">
            <summary>
            Helper class that invokes different scopes
            </summary>
        </member>
        <member name="F:Lokad.Rules.Scope.RulePathSeprator">
            <summary>
            Rule path separator char
            </summary>
        </member>
        <member name="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)">
            <summary>
            Returns true if <paramref name="level"/>
            is <see cref="F:Lokad.Rules.RuleLevel.Error"/> or higher
            </summary>
            <param name="level">The level to check.</param>
            <returns>true if the condition is met</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.WhenAny(Lokad.Rules.RuleLevel)">
            <summary>
            Returns true if <paramref name="level"/>
            is not <see cref="F:Lokad.Rules.RuleLevel.None"/>
            </summary>
            <param name="level">The level.</param>
            <returns>true if the condition is met</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.WhenWarn(Lokad.Rules.RuleLevel)">
            <summary>
            Returns true if <paramref name="ruleLevel"/>
            is <see cref="F:Lokad.Rules.RuleLevel.Warn"/> or higher
            </summary>
            <param name="ruleLevel">The rule level.</param>
            <returns>true if the condition is met</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.WhenNone(Lokad.Rules.RuleLevel)">
            <summary>
            Returns true if <paramref name="ruleLevel"/>
            is <see cref="F:Lokad.Rules.RuleLevel.None"/> or higher
            </summary>
            <param name="ruleLevel">The rule level.</param>
            <returns>true if the condition is met</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.ForValidation(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
            <summary>
            Creates scope that runs full check and then fails with 
            <see cref="T:Lokad.Rules.RuleException"/>, if the resulting 
            <see cref="T:Lokad.Rules.RuleLevel"/>  matches the <paramref name="predicate"/>
            </summary>
            <param name="name">The name for the scope.</param>
            <param name="predicate">The predicate.</param>
            <returns>new scope instance</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.ForEnforce(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
            <summary>
            Creates scope that throws <see cref="T:Lokad.Rules.RuleException"/> as soon as
            first message matching <paramref name="predicate"/> is received.
            </summary>
            <param name="scopeName">Name of the scope.</param>
            <param name="predicate">The predicate.</param>
            <returns>new scope instance</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.ForEnforceArgument(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
            <summary>
            Creates scope that throws <see cref="T:System.ArgumentException"/> as soon as
            first message matching <paramref name="predicate"/> is received.
            </summary>
            <param name="scopeName">Name of the scope.</param>
            <param name="predicate">The predicate.</param>
            <returns>new scope instance</returns>
        </member>
        <member name="M:Lokad.Rules.Scope.IsError``1(``0,Lokad.Rules.Rule{``0}[])">
            <summary>  Determines whether the specified item has problems of 
            <see cref="F:Lokad.Rules.RuleLevel.Error"/> or higher.  </summary>
            <typeparam name="TItem">type of the item to run rules against</typeparam>
            <param name="item">The item to run rules against.</param>
            <param name="rules">The rules to execute.</param>
            <returns>
            	<c>true</c> if the specified item is in error state; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Rules.Scope.IsValid``1(``0,Lokad.Rules.Rule{``0}[])">
            <summary>  Determines whether the specified item does not have any problems </summary>
            <typeparam name="TItem">type of the item to run rules against</typeparam>
            <param name="item">The item to run rules against.</param>
            <param name="rules">The rules to execute.</param>
            <returns>
            	<c>true</c> if the specified item is in error state; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Rules.Scope.IsWarn``1(``0,Lokad.Rules.Rule{``0}[])">
            <summary>  Determines whether the specified item has problems of 
            <see cref="F:Lokad.Rules.RuleLevel.Warn"/> or higher.  </summary>
            <typeparam name="TItem">type of the item to run rules against</typeparam>
            <param name="item">The item to run rules against.</param>
            <param name="rules">The rules to execute.</param>
            <returns>
            	<c>true</c> if the specified item is in warning state; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Rules.Scope.GetMessages``1(``0,System.String,Lokad.Rules.Rule{``0}[])">
            <summary> Collects all rule messages associated with the 
            specified <paramref name="item"/> </summary>
            <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
            <param name="item">The item to run the rules against.</param>
            <param name="name">The name of the scope.</param>
            <param name="rules">The rules to execute.</param>
            <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage"/></returns>
        </member>
        <member name="M:Lokad.Rules.Scope.GetMessages(System.String,System.Action{Lokad.Rules.IScope})">
            <summary>
            Gets the messages created by action being executed against the scope.
            </summary>
            <param name="name">The name for the scope.</param>
            <param name="scopeAction">The scope action.</param>
            <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage"/></returns>
        </member>
        <member name="M:Lokad.Rules.Scope.GetMessages``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
            <summary>
            Collects all rule messages associated with the
            specified <paramref name="itemReference"/>
            </summary>
            <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
            <param name="itemReference">The item reference.</param>
            <param name="rules">The rules to execute.</param>
            <returns>
            read-only collection of <see cref="T:Lokad.Rules.RuleMessage"/>
            </returns>
        </member>
        <member name="M:Lokad.Rules.Scope.GetMessagesForMany``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
            <summary>
            Collects all rule messages associated with the
            specified <paramref name="sequenceReference"/>
            </summary>
            <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
            <param name="sequenceReference">The sequence reference.</param>
            <param name="rules">The rules to execute.</param>
            <returns> read-only collection of <see cref="T:Lokad.Rules.RuleMessage"/> </returns>
        </member>
        <member name="M:Lokad.Rules.Scope.GetMessagesForMany``1(System.Collections.Generic.IEnumerable{``0},System.String,Lokad.Rules.Rule{``0}[])">
            <summary> Collects all rule messages associated with the 
            specified <paramref name="items"/> </summary>
            <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
            <param name="items">The item to run the rules against.</param>
            <param name="name">The name of the scope.</param>
            <param name="rules">The rules to execute.</param>
            <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage"/></returns>
        </member>
        <member name="M:Lokad.Rules.Scope.Validate``1(``0,Lokad.Rules.Rule{``0}[])">
            <summary>
            Runs full validation scan of the specified item and throws error
            if the level is not <see cref="F:Lokad.Rules.RuleLevel.None"/>
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="item">The item to validate.</param>
            <param name="rules">The rules.</param>
            <exception cref="T:Lokad.Rules.RuleException">if any rules have failed</exception>
        </member>
        <member name="M:Lokad.Rules.Scope.ValidateMany``1(System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
            <summary>
            Runs full validation scan of the specified collection
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="items">The collection to validate.</param>
            <param name="rules">The validators.</param>
            <exception cref="T:Lokad.Rules.RuleException">if any rules have failed</exception>
        </member>
        <member name="M:Lokad.Rules.Scope.ComposePath(System.String,System.String)">
            <summary>
            Composes the path for the <see cref="T:Lokad.Rules.Rule`1"/>.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="suffix">The suffix.</param>
            <returns>composed path</returns>
            <exception cref="T:System.ArgumentException">if path parameters are null or empty</exception>
        </member>
        <member name="M:Lokad.Rules.Scope.ForLogging(System.String,System.Text.StringBuilder)">
            <summary>
            Creates new scope for logging into the provided string builder
            </summary>
            <param name="scopeName">Name of the scope.</param>
            <param name="log">The builder to write to.</param>
            <returns>composed scope</returns>
        </member>
        <member name="T:Lokad.Rules.ExtendIScope">
            <summary> /// <para>Extensions that encapsulate some repetitive tasks
             of setting scopes, and calling validation rules.</para>
             <para>Basically that's the class that links together scope 
             and validation logics.</para></summary>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Error(Lokad.Rules.IScope,System.String,System.Object[])">
            <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.Error"/> 
            message into the  <paramref name="scope"/> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> </summary>
            <param name="scope">The scope.</param>
            <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)"/>).</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Error(Lokad.Rules.IScope,System.String)">
            <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.Error"/> 
            message into the  <paramref name="scope"/> </summary>
            <param name="scope">The scope.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Warn(Lokad.Rules.IScope,System.String,System.Object[])">
            <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.Warn"/> 
            message into the  <paramref name="scope"/> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> </summary>
            <param name="scope">The scope.</param>
            <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)"/>).</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Warn(Lokad.Rules.IScope,System.String)">
            <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.Warn"/> 
            message into the  <paramref name="scope"/> </summary>
            <param name="scope">The scope.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Info(Lokad.Rules.IScope,System.String,System.Object[])">
            <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.None"/> 
            message into the  <paramref name="scope"/> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> </summary>
            <param name="scope">The scope.</param>
            <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)"/>).</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Info(Lokad.Rules.IScope,System.String)">
            <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.None"/> 
            message into the  <paramref name="scope"/> </summary>
            <param name="scope">The scope.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.IsError(Lokad.Rules.IScope)">
            <summary> Determines whether the specified <paramref name="scope"/>
            is in the <see cref="F:Lokad.Rules.RuleLevel.Error"/> state. </summary>
            <param name="scope">The scope.</param>
            <returns>
            	<c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.Error"/> 
            state; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.IsNone(Lokad.Rules.IScope)">
            <summary> Determines whether the specified <paramref name="scope"/>
            is in the <see cref="F:Lokad.Rules.RuleLevel.None"/> state. </summary>
            <param name="scope">The scope.</param>
            <returns>
            	<c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.None"/> 
            state; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.IsWarn(Lokad.Rules.IScope)">
            <summary> Determines whether the specified <paramref name="scope"/>
            is in the <see cref="F:Lokad.Rules.RuleLevel.Warn"/> state. </summary>
            <param name="scope">The scope.</param>
            <returns>
            	<c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.Warn"/> 
            state; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Validate``1(Lokad.INamedProvider{Lokad.Rules.IScope},``0,System.String,Lokad.Rules.Rule{``0}[])">
            <summary>
            Validates some member using the <paramref name="scopeProvider"/>.
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="scopeProvider">The scope provider.</param>
            <param name="item">The item to validate.</param>
            <param name="name">The name of the variable that holds item to validate.</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Validate``1(Lokad.Rules.IScope,``0,System.String,Lokad.Rules.Rule{``0}[])">
            <summary> Validates some member using the provided <paramref name="parentScope"/>.
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="parentScope">The parent scope.</param>
            <param name="item">The item to validate.</param>
            <param name="name">The name of the variable that holds item to validate.</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Validate``1(Lokad.Rules.IScope,System.Func{``0},Lokad.Rules.Rule{``0}[])">
            <summary>
            Validates some member using the provided <paramref name="parentScope"/>.
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="parentScope">The parent scope.</param>
            <param name="property">The property reference.</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.ValidateMany``1(Lokad.Rules.IScope,System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
            <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1"/> member using the provided <paramref name="parentScope"/>.
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="parentScope">The parent scope.</param>
            <param name="propertyReference">Reference to collection property to validate.</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.ValidateMany``1(Lokad.Rules.IScope,System.Collections.Generic.IEnumerable{``0},System.String,Lokad.Rules.Rule{``0}[])">
            <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1"/> member using the provided <paramref name="parentScope"/>.
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="parentScope">The parent scope.</param>
            <param name="items">The collection to validate.</param>
            <param name="name">The name of the variable that holds item to validate.</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.ValidateMany``1(Lokad.Rules.IScope,System.Collections.Generic.ICollection{``0},System.String,System.Int32,Lokad.Rules.Rule{``0}[])">
            <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1"/> member using the provided <paramref name="parentScope"/>.
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="parentScope">The parent scope.</param>
            <param name="items">The collection to validate.</param>
            <param name="name">The name of the variable that holds item to validate.</param>
            <param name="limit">The limit (if collection is bigger, then validation will not continue).</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.ValidateInScope``1(Lokad.Rules.IScope,``0,Lokad.Rules.Rule{``0}[])">
            <summary>
            Runs the specified rules against the provided object in the current scope
            </summary>
            <typeparam name="T">type of the object being validated</typeparam>
            <param name="scope">The scope.</param>
            <param name="item">The item to validate.</param>
            <param name="rules">The rules to execute.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.ValidateInScope``1(Lokad.Rules.IScope,System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
            <summary>
            Runs validation rules against some some <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">type of the items being validated</typeparam>
            <param name="parentScope">The parent scope.</param>
            <param name="items">Collection of the items to validate</param>
            <param name="rules">The rules to run.</param>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Lower(Lokad.Rules.IScope)">
            <summary>
            Creates a wrapper that lowers the importance of messages
            being passed to the specified <paramref name="scope"/>.
            </summary>
            <param name="scope">The scope to wrap.</param>
            <returns>new instance of the wrapper</returns>
        </member>
        <member name="M:Lokad.Rules.ExtendIScope.Raise(Lokad.Rules.IScope)">
            <summary>
            Creates a wrapper that boosts the <see cref="T:Lokad.Rules.RuleLevel"/> of
            messages being passed to the specified<paramref name="scope"/>.
            </summary>
            <param name="scope">The scope to wrap.</param>
            <returns>new instance of the wrapper</returns>
        </member>
        <member name="T:Lokad.Rules.TrackScope">
            <summary>
            <see cref="T:Lokad.Rules.IScope"/> that merely keeps track of the worst level. 
            </summary>
        </member>
        <member name="M:Lokad.Rules.TrackScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.TrackScope"/> class.
            </summary>
        </member>
        <member name="T:Lokad.StringUtil">
            <summary>
            Helper methods for <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Lokad.StringUtil.FormatInvariant(System.String,System.Object[])">
            <summary>
            Formats the string using InvariantCulture
            </summary>
            <param name="format">The format.</param>
            <param name="args">The args.</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Lokad.StringUtil.MemberNameToCaption(System.String)">
            <summary>
            Converts "Class.SomeName" to "Class - Some Name"
            </summary>
        </member>
        <member name="T:Lokad.Threading.ReaderWriterLockSlimExtensions">
            <summary>
            Helper class that simplifies <see cref="T:System.Threading.ReaderWriterLockSlim"/> usage
            </summary>
        </member>
        <member name="M:Lokad.Threading.ReaderWriterLockSlimExtensions.GetReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Gets the read lock object, that is released when the object is disposed.
            </summary>
            <param name="slimLock">The slim lock object.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.Threading.ReaderWriterLockSlimExtensions.GetWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Gets the write lock, that is released when the object is disposed.
            </summary>
            <param name="slimLock">The slim lock.</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.Threading.ReaderWriterLockSlimExtensions.GetUpgradeableReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Gets the upgradeable read lock, that is released, when the object is disposed
            </summary>
            <param name="slimLock">The slim lock.</param>
            <returns></returns>
        </member>
        <member name="T:Lokad.Pair`2">
            <summary>
            Tuple class with 2 items
            </summary>
            <typeparam name="TKey">The type of the first item.</typeparam>
            <typeparam name="TValue">The type of the second item.</typeparam>
        </member>
        <member name="M:Lokad.Pair`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Pair`2"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
        </member>
        <member name="P:Lokad.Pair`2.Key">
            <summary>
            Gets the key (or Item1).
            </summary>
            <value>The key.</value>
        </member>
        <member name="P:Lokad.Pair`2.Value">
            <summary>
            Gets the value (or Item2).
            </summary>
            <value>The value.</value>
        </member>
        <member name="T:Lokad.Reflection.Reflect">
            <summary>
            Helper class for the IL-based strongly-typed reflection
            </summary>
            <remarks>This class is not supported by Silverlight 2.0, yet</remarks>
        </member>
        <member name="M:Lokad.Reflection.Reflect.Variable``1(System.Func{``0})">
            <summary>
            Retrieves via IL the information of the <b>local</b> variable passed in the expression.
            <code>
            var myVar = "string";
            var info = Reflect.Variable(() =&gt; myVar)
            </code>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression containing the local variable to reflect.</param>
            <returns>information about the variable (if able to retrieve)</returns>
            <exception cref="T:Lokad.Reflection.ReflectLambdaException">if the provided expression is not a simple variable reference</exception>
        </member>
        <member name="M:Lokad.Reflection.Reflect.VariableSafely``1(System.Func{``0})">
            <summary>
            Retrieves via IL the information of the <b>local</b> variable passed in the expression.
            <code>
            var myVar = "string";
            var info = Reflect.Variable(() =&gt; myVar)
            </code>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression containing the local variable to reflect.</param>
            <returns>information about the variable (if able to retrieve)</returns>
        </member>
        <member name="M:Lokad.Reflection.Reflect.Property``1(System.Func{``0})">
            <summary>
            Retrieves via IL the <em>getter method</em> for the property being reflected.
            <code>
            var i2 = new
            {
              MyProperty = "Value"
            }; 
            var info = Reflect.Property(() =&gt; i2.Property);
            // info will have name of "get_MyProperty"
            </code>
            </summary>
            <typeparam name="T">type of the property to reflect</typeparam>
            <param name="expression">The expression.</param>
            <returns>getter method for the property.</returns>
            <exception cref="T:Lokad.Reflection.ReflectLambdaException">if reference is not a simple property</exception>
        </member>
        <member name="M:Lokad.Reflection.Reflect.PropertySafely``1(System.Func{``0})">
            <summary>
            Retrieves via IL the <em>getter method</em> for the property being reflected.
            <code>
            var i2 = new
            {
              MyProperty = "Value"
            }; 
            var info = Reflect.Property(() => i2.Property);
            // info will have name of "get_MyProperty"
            </code>
            </summary>
            <typeparam name="T">type of the property to reflect</typeparam>
            <param name="expression">The expression.</param>
            <returns>getter method for the property.</returns>
        </member>
        <member name="T:Lokad.Triple`3">
            <summary>
            Tuple class with 3 items
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
        </member>
        <member name="M:Lokad.Triple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Triple`3"/> class.
            </summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
        </member>
        <member name="T:Lokad.Tuple">
            <summary>
            Helper class that simplifies tuple inline generation
            </summary>
             <example>
            Tuple.From("Mike",1,true)
            </example>
        </member>
        <member name="M:Lokad.Tuple.From``2(``0,``1)">
            <summary>
            Creates <see cref="T:Lokad.Pair`2"/> out of two arguments
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.Tuple.From``3(``0,``1,``2)">
            <summary>
            Creates <see cref="T:Lokad.Triple`3"/> out of the three arguments
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <returns>New tuple instance</returns>
        </member>
        <member name="M:Lokad.Tuple.From``4(``0,``1,``2,``3)">
            <summary>
            Creates <see cref="T:Lokad.Tuple`4"/> out of four arguments
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth.</typeparam>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <returns>New instance</returns>
        </member>
        <member name="M:Lokad.Tuple.From``5(``0,``1,``2,``3,``4)">
            <summary>
            Creates <see cref="T:Lokad.Tuple`4"/> out of four arguments
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
            <returns>New instance</returns>
        </member>
        <member name="M:Lokad.Tuple.From``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            Creates <see cref="T:Lokad.Tuple`4"/> out of four arguments
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
            <param name="sixth">The sixth item.</param>
            <returns>New instance</returns>
        </member>
        <member name="M:Lokad.Tuple.From``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Creates <see cref="T:Lokad.Tuple`4"/> out of four arguments
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
            <param name="third">The third item.</param>
            <param name="fourth">The fourth item.</param>
            <param name="fifth">The fifth item.</param>
            <param name="sixth">The sixth item.</param>
            <param name="seventh">The seventh item.</param>
            <returns>New instance</returns>
        </member>
        <member name="T:Lokad.ExtendType">
            <summary>
            Helper related to the <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:Lokad.ExtendType.GetAttributes``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
             Extension method to retrieve attributes from the type.
            </summary>
            <param name="target">Type to perform operation upon</param>
            <param name="inherit"><see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)"/></param>
            <typeparam name="T">Attribute to use</typeparam>
            <returns>Empty array of <typeparamref name="T"/> if there are no attributes</returns>
        </member>
        <member name="M:Lokad.ExtendType.GetAttribute``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
             <summary>
             Returns single attribute from the type.
             </summary>
             <typeparam name="T">Attribute to use</typeparam>
             <param name="target">Attribute provider</param>
            <param name="inherit"><see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)"/></param>
             <returns><em>Null</em> if the attribute is not found</returns>
             <exception cref="T:System.InvalidOperationException">If there are 2 or more attributes</exception>
        </member>
        <member name="M:Lokad.ExtendType.MarkedWith``1(System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
            <summary>
            Selects non-abstract types marked with the specified attribute.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="types"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="T:Lokad.Diagnostics.ExecutionCounterGroup">
            <summary>
            Helper class to simplify counter creation syntax
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.Register">
            <summary>
            Registers the counters in the global cache
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.Register(Lokad.Diagnostics.ExecutionCounters)">
            <summary>
            Registers the counters in the specified cache
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.CreateCounter(System.String,System.Int32,System.Int32)">
            <summary>
            Creates the counter and adds it to the internal collection.
            </summary>
            <param name="name">The name for the new counter.</param>
            <param name="openCounterCount">The open counter count.</param>
            <param name="closeCounterCount">The close counter count.</param>
            <returns>instance of the created counter</returns>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.CreateCounter(System.Linq.Expressions.Expression{System.Action},System.Int32,System.Int32)">
            <summary> Creates the counter and adds it to the internal collection. </summary>
            <param name="expression">The expression to derive counter name from.</param>
            <param name="openCounterCount">The open counter count.</param>
            <param name="closeCounterCount">The close counter count.</param>
            <returns>instance of the new counter</returns>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.CreateCounterForCtor``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Int32,System.Int32)">
            <summary> Creates the counter and adds it to the internal collection. </summary>
            <param name="expression">The expression to derive counter name from.</param>
            <param name="openCounterCount">The open counter count.</param>
            <param name="closeCounterCount">The close counter count.</param>
            <returns>instance of the new counter</returns>
        </member>
        <member name="T:Lokad.Diagnostics.ExecutionCounterGroup`1">
            <summary>
            Helper class to simplify counter creation syntax
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounterGroup`1.CreateCounter(System.Linq.Expressions.Expression{System.Action{`0}},System.Int32,System.Int32)">
            <summary>
            Creates new counter and adds it to the internal collection
            </summary>
            <param name="call">The call to derive counter name from.</param>
            <param name="openCounterCount">The open counter count.</param>
            <param name="closeCounterCount">The close counter count.</param>
            <returns>instance of the created counter</returns>
        </member>
        <member name="T:Lokad.Enforce">
            <summary>
            Helper class allows to follow the principles defined by Microsoft P&amp;P team.
            </summary>
        </member>
        <member name="M:Lokad.Enforce.Argument``1(System.Func{``0})">
            <summary>
            <para>Throws exception if the provided object is null. </para>
            <code>Enforce.Argument(() =&gt; args);</code> 
            </summary>
            <typeparam name="TValue">type of the class to check</typeparam>
            <param name="argumentReference">The argument reference to check.</param>
            <exception cref="T:System.ArgumentNullException">If the class reference is null.</exception>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.Arguments``2(System.Func{``0},System.Func{``1})">
            <summary>
            	<para>Throws exception if one of the provided objects is null. </para>
            	<code>Enforce.Arguments(() =&gt; controller, () =&gt; service);</code>
            </summary>
            <param name="first">The first argument to check for</param>
            <param name="second">The second argument to check for.</param>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.Arguments``3(System.Func{``0},System.Func{``1},System.Func{``2})">
            <summary>
            	<para>Throws exception if one of the provided objects is null. </para>
            	<code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the third argument.</typeparam>
            <param name="first">The first argument to check</param>
            <param name="second">The second argument to check.</param>
            <param name="third">The third argument to check.</param>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.Arguments``4(System.Func{``0},System.Func{``1},System.Func{``2},System.Func{``3})">
            <summary>
            	<para>Throws exception if one of the provided objects is null. </para>
            	<code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the third argument.</typeparam>
            <typeparam name="T4">The type of the fourth argument.</typeparam>
            <param name="first">The first argument to check.</param>
            <param name="second">The second argument to check.</param>
            <param name="third">The third argument to check.</param>
            <param name="fourth">The fourth argument to check.</param>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.Arguments``5(System.Func{``0},System.Func{``1},System.Func{``2},System.Func{``3},System.Func{``4})">
            <summary>
            	<para>Throws exception if one of the provided objects is null. </para>
            	<code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the third argument.</typeparam>
            <typeparam name="T4">The type of the fourth argument.</typeparam>
            <typeparam name="T5">The type of the fifth argument.</typeparam>
            <param name="first">The first argument to check.</param>
            <param name="second">The second argument to check.</param>
            <param name="third">The third argument to check.</param>
            <param name="fourth">The fourth argument to check.</param>
            <param name="fifth">The fifth argument to check.</param>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.ArgumentNotEmpty(System.Func{System.String})">
            <summary>
            Throws proper exception if the provided string argument is null or empty. 
            </summary>
            <returns>Original string.</returns>
            <exception cref="T:System.ArgumentException">If the string argument is null or empty.</exception>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.That(System.Boolean,System.String)">
            <summary>
            Throws exception if the check does not pass.
            </summary>
            <param name="check">if set to <c>true</c> then check will pass.</param>
            <param name="name">The name of the assertion.</param>
            <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
        </member>
        <member name="M:Lokad.Enforce.That(System.Boolean,System.String,System.Object[])">
            <summary>
            Throws exception if the check does not pass.
            </summary>
            <param name="check">if set to <c>true</c> then check will pass.</param>
            <param name="message">The message.</param>
            <param name="arguments">The format arguments.</param>
            <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
        </member>
        <member name="M:Lokad.Enforce.That(System.Boolean)">
            <summary>
            Throws exception if the check does not pass.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
        </member>
        <member name="M:Lokad.Enforce.With``1(System.Boolean,System.String,System.Object[])">
            <summary>
            Throws <typeparamref name="TException"/> if the <paramref name="check"/>
            failes
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="check">Check that should be true.</param>
            <param name="message">The message.</param>
            <param name="args">String arguments.</param>
            <exception cref="T:System.Exception">of <typeparamref name="TException"/> type</exception>
        </member>
        <member name="M:Lokad.Enforce.Argument(System.Boolean,System.String,System.String)">
            <summary> Throws exception if the argument fails the <paramref name="check"/> </summary>
            <param name="check">Throw exception if false.</param>
            <param name="paramName">Name of the param.</param>
            <param name="checkName">Name of the check.</param>
            <exception cref="T:System.ArgumentException">When the argument fails the check</exception>
        </member>
        <member name="M:Lokad.Enforce.NotNull``1(System.Func{``0})">
            <summary>
            Throws proper exception if the class reference is null.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="value">Class reference to check.</param>
            <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.NotNull``1(``0)">
            <summary>
            Throws proper exception if the class reference is null.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="value">Class reference to check.</param>
            <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
        </member>
        <member name="M:Lokad.Enforce.NotNull``1(``0,System.String)">
            <summary>
            Throws proper exception if the class reference is null.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="value">Class reference to check.</param>
            <param name="name">The name.</param>
            <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
        </member>
        <member name="M:Lokad.Enforce.ArgumentNotNull``1(``0,System.String)">
            <summary>
            Throws proper exception if the provided class reference is null.
            Can be used for inline checks.
            </summary>
            <typeparam name="TValue">Class type</typeparam>
            <param name="value">Class reference to check.</param>
            <param name="argumentName">Name of the argument.</param>
            <returns>Original reference.</returns>
            <exception cref="T:System.ArgumentNullException">If the class reference is null.</exception>
        </member>
        <member name="M:Lokad.Enforce.Argument``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
            <summary>
            Runs the rules against single argument, using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)"/>
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="argumentReference">The argument reference.</param>
            <param name="rules">The rules.</param>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
            <exception cref="T:System.ArgumentException">When any rule fails</exception>
        </member>
        <member name="M:Lokad.Enforce.Argument``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
            <summary>
            Runs the rules against single collection, using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)"/>
            </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="items">The items to validate.</param>
            <param name="rules">The rules.</param>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
            <exception cref="T:System.ArgumentException">When any rule fails</exception>
        </member>
        <member name="M:Lokad.Enforce.That``1(``0,Lokad.Rules.Rule{``0}[])">
            <summary> Runs the rules against single argument, 
            using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)"/>.
             </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="item">The item to validate.</param>
            <param name="rules">The rules.</param>
            <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
        </member>
        <member name="M:Lokad.Enforce.That``1(System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
            <summary> Runs the rules against single collection, using 
            scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)"/>.</summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="items">The items to validate.</param>
            <param name="rules">The rules.</param>
            <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
        </member>
        <member name="M:Lokad.Enforce.That``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
            <summary> Runs the rules against single item, using 
            scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)"/>.</summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="argumentReference">The item to validate.</param>
            <param name="rules">The rules.</param>
            <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="M:Lokad.Enforce.That``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
            <summary> Runs the rules against collection, 
            using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)"/> </summary>
            <typeparam name="T">type of the item to validate</typeparam>
            <param name="collectionReference">The items to validate.</param>
            <param name="rules">The rules.</param>
            <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
            <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
        </member>
        <member name="T:Lokad.ExtendICollection">
            <summary>
            Simple helper extensions for <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="M:Lokad.ExtendICollection.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds all items to the target collection
            </summary>
            <typeparam name="T">type of the item within the collection</typeparam>
            <param name="collection">The collection</param>
            <param name="items">items to add to the collection</param>
            <returns>same collection instance</returns>
        </member>
        <member name="M:Lokad.ExtendICollection.RemoveRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Removes all items from the target collection
            </summary>
            <typeparam name="T">type of the item within the collection</typeparam>
            <param name="collection">The collection.</param>
            <param name="items">The items.</param>
            <returns>same collection instance</returns>
        </member>
        <member name="M:Lokad.ExtendICollection.IsEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Shortcut to determine whether the specified <see cref="T:System.Collections.Generic.ICollection`1"/> is empty.
            </summary>
            <typeparam name="T">items in the collection</typeparam>
            <param name="self">The collection.</param>
            <returns>
            	<c>true</c> if the specified self is empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Lokad.ICommand">
            <summary>
            Generic interface for the command pattern.
            </summary>
        </member>
        <member name="M:Lokad.ICommand.Execute">
            <summary>
            Encapsulates action
            </summary>
        </member>
        <member name="T:System.Linq.ExtendIEnumerable">
            <summary>
            Helper methods for the <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs the specified <see cref="T:System.Action`1"/> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">Enumerable to extend</param>
            <param name="action">Action to perform</param>
            <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Performs the specified <see cref="T:System.Action`1"/> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">Enumerable to extend</param>
            <param name="action">Action to perform; second parameter represents the index</param>
            <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Applies the specified action to the target <paramref name="enumerable"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="action">The action to execute against every item.</param>
            <returns>enumerator</returns>
            <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Applies the specified action to the target <paramref name="enumerable"/>.
            </summary>
            <typeparam name="TSource">Type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="action">The action to execute against every item; second
            parameter represents the index.</param>
            <returns>enumerator</returns>
            <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Returns <em>True</em> as soon as the first member of <paramref name="enumerable"/>
            mathes <paramref name="predicate"/>
            </summary>
            <typeparam name="TSource">Type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable</param>
            <param name="predicate">The predicate.</param>
            <returns>true if the <paramref name="enumerable"/> contains any elements
            matching <paramref name="predicate"/></returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Exists``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if the provided enumerable has anything
            </summary>
            <typeparam name="TSource">Type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable.</param>
            <returns>true if the sequence contains any elements</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Appends the <paramref name="items"/> to the <paramref name="enumerable"/>.
            </summary>
            <typeparam name="TSource">type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="items">The item.</param>
            <returns>new sequence</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Appends the specified <paramref name="range"/> to the <paramref name="enumerable"/>.
            </summary>
            <typeparam name="T">type of the item to operate with</typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="range">The range.</param>
            <returns>new enumerator instance</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Prepends the specified <paramref name="enumerable"/> with the <paramref name="items"/>.
            </summary>
            <typeparam name="T">type of the item to operate with</typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="items">The item.</param>
            <returns>new enumerator instance</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">The enumerable.</param>
            <returns>hashset instance</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToSet``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1"/>
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="selector">The selector.</param>
            <returns>hashset instance</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the minimum value in a generic sequence, using the provided comparer
            </summary>
            <typeparam name="T">Type of the elements of <paramref name="source"/></typeparam>
            <param name="source">Original sequence.</param>
            <param name="comparer">The comparer.</param>
            <returns>Maximum value</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the maximum value in a generic sequence using the provided comparer.
            </summary>
            <typeparam name="T">Type of the elements of <paramref name="source"/></typeparam>
            <param name="source">Original sequence.</param>
            <param name="comparer">The comparer.</param>
            <returns>Maximum value</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Concatenates a specified separator between each element of a specified <paramref name="strings"/>, 
            yielding a single concatenated string.
            </summary>
            <param name="strings">The strings.</param>
            <param name="separator">The separator.</param>
            <returns>concatenated string</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Int32},System.Int32)">
            <summary>
            <para>Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength"/>.</para>
            <para>Each collection will have total <em>weight</em> equal or less than <paramref name="maxSliceWeight"/></para>
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="source">The source collection to slice.</param>
            <param name="sliceLength">Length of the slice.</param>
            <param name="weightDelegate">Function to calculate <em>weight</em> of each item in the collection</param>
            <param name="maxSliceWeight">The max item weight.</param>
            <returns>enumerator over the results</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength"/>
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="source">The source.</param>
            <param name="sliceLength">Maximum length of the slice.</param>
            <returns>lazy enumerator of the collection of arrays</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToJaggedArray``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts collection of collections to jagged array
            </summary>
            <typeparam name="T">type of the items in collection</typeparam>
            <param name="collection">The collection.</param>
            <returns>jagged array</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Shorthand extension method for converting enumerables into the arrays
            </summary>
            <typeparam name="TSource">The type of the source array.</typeparam>
            <typeparam name="TTarget">The type of the target array.</typeparam>
            <param name="self">The collection to convert.</param>
            <param name="converter">The converter.</param>
            <returns>target array instance</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            Shorthand extension method for converting enumerables into the arrays
            </summary>
            <typeparam name="TSource">The type of the source array.</typeparam>
            <typeparam name="TTarget">The type of the target array.</typeparam>
            <param name="self">The collection to convert.</param>
            <param name="converter">The converter, where the second parameter is an index of item being converted.</param>
            <returns>target array instance</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            returns distinct values from a sequence by using projecting each item to a new
            sequence with <paramref name="projection"/> and then selecting
            distinct values from it.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <typeparam name="TProjected">The type of the projected item.</typeparam>
            <param name="enumerable">The sequence to work with.</param>
            <param name="projection">The projection function.</param>
            <returns>sequence of distinct values</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Retrieves first value from the <paramref name="sequence"/>
            </summary>
            <typeparam name="TSource">The type of the source sequence.</typeparam>
            <param name="sequence">The source.</param>
            <param name="predicate">The predicate.</param>
            <returns>first value</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Retrieves first value from the <paramref name="sequence"/>
            </summary>
            <typeparam name="TSource">The type of the source sequence.</typeparam>
            <param name="sequence">The source.</param>
            <returns>first value or empty result, if it is not found</returns>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToIndexed``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Applies the integral indexer to the sequence in a lazy manner
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="source">The sequence.</param>
            <returns>indexed sequence</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="source"/> is null</exception>
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.ToIndexDictionary``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerates and returns a mapping that associated the items with their respective
            indices (positions) within the enumeration.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="source">The source.</param>
            <returns>a dictionary</returns>
            <remarks><para>Typical usage is <c>coll.ToIndex()["foo"]</c> that returns
            the position of the item <c>"foo"</c> in the initial collection.</para>
            <para>if multiple similar entries are present in the original collection,
            index of the first entry is recorded.
            </para>
            
            </remarks>
            
        </member>
        <member name="M:System.Linq.ExtendIEnumerable.SelectValues``1(System.Collections.Generic.IEnumerable{Lokad.Maybe{``0}})">
            <summary>
            Selects the values from a sequence of optionals.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="sequence">The sequence.</param>
            <returns>enumerable that contains values</returns>
        </member>
        <member name="T:Lokad.Diagnostics.ExecutionCounter">
            <summary> <para>
            Class to provide simple measurement of some method calls. 
            This class has been designed to provide light performance monitoring
            that could be used for instrumenting methods in production. It does 
            not use any locks and uses design to avoid 90% of concurrency issues.
            </para><para>
            Counters are designed to be "cheap" and throwaway, so we basically we
            don't care about the remaining 10%
            </para><para>
            The usage idea is simple - data is captured from the counters at
            regular intervals of time (i.e. 5-10 minutes). Counters are reset 
            after that. Data itself is aggregated on the monitoring side. 
            If there are some bad values (i.e. due to some rare race condition
            between multiple threads and monitoring scan) then the counter data
            is simply discarded.
            </para></summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounter.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExecutionCounter"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="openCounterCount">The open counter count.</param>
            <param name="closeCounterCount">The close counter count.</param>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounter.Open(System.Int64[])">
            <summary>
            Open the specified counter and adds the provided values to the openCounters collection
            </summary>
            <param name="openCounters">The open counters.</param>
            <returns>timestamp for the operation</returns>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounter.Close(System.Int64,System.Int64[])">
            <summary>
            Closes the specified timestamp.
            </summary>
            <param name="timestamp">The timestamp.</param>
            <param name="closeCounters">The close counters.</param>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounter.Reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionCounter.ToStatistics">
            <summary>
            Converts this instance to <see cref="T:Lokad.Diagnostics.ExecutionStatistics"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lokad.Diagnostics.ExecutionStatistics">
            <summary>
            Statistics about some execution counter
            </summary>
        </member>
        <member name="M:Lokad.Diagnostics.ExecutionStatistics.#ctor(System.String,System.Int64,System.Int64,System.Int64[],System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExecutionStatistics"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="openCount">The open count.</param>
            <param name="closeCount">The close count.</param>
            <param name="counters">The counters.</param>
            <param name="runningTime">The running time.</param>
        </member>
        <member name="P:Lokad.Diagnostics.ExecutionStatistics.OpenCount">
            <summary>
            Gets the number of times the counter has been opened
            </summary>
            <value>The open count.</value>
        </member>
        <member name="P:Lokad.Diagnostics.ExecutionStatistics.CloseCount">
            <summary>
            Gets the number of times the counter has been properly closed.
            </summary>
            <value>The close count.</value>
        </member>
        <member name="P:Lokad.Diagnostics.ExecutionStatistics.Counters">
            <summary>
            Gets the native counters collected by this counter.
            </summary>
            <value>The counters.</value>
        </member>
        <member name="P:Lokad.Diagnostics.ExecutionStatistics.RunningTime">
            <summary>
            Gets the total running time between open and close statements in ticks.
            </summary>
            <value>The running time expressed in 100-nanosecond units.</value>
        </member>
        <member name="P:Lokad.Diagnostics.ExecutionStatistics.Name">
            <summary>
            Gets the name for this counter.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:Lokad.ExtendStream">
            <summary>
            Simple helper extensions for the <see cref="T:System.IO.Stream"/>
            </summary>
        </member>
        <member name="M:Lokad.ExtendStream.Compress(System.IO.Stream)">
            <summary>
            Wraps the specified stream with Compression stream
            </summary>
            <param name="stream">The stream to compress</param>
            <returns>compressing stream</returns>
        </member>
        <member name="M:Lokad.ExtendStream.Compress(System.IO.Stream,System.Boolean)">
            <summary>
            Wraps the specified stream with Compression stream
            </summary>
            <param name="stream">The stream the stream to compress.</param>
            <param name="leaveOpen"><c>true</c> to leave the stream open; overwise <c>false</c>.</param>
            <returns>compressing stream</returns>
        </member>
        <member name="M:Lokad.ExtendStream.Decompress(System.IO.Stream)">
            <summary>
            Wraps the stream with Decompressing stream
            </summary>
            <param name="stream">The stream to decompress.</param>
            <returns>decompressing stream</returns>
        </member>
        <member name="M:Lokad.ExtendStream.Decompress(System.IO.Stream,System.Boolean)">
            <summary>
            Wraps the stream with Decompressing stream
            </summary>
            <param name="stream">The stream to decompress.</param>
            <param name="leaveOpen"><c>true</c> to leave the stream open; overwise <c>false</c>.</param>
            <returns>decompressing stream</returns>
        </member>
        <member name="M:Lokad.ExtendStream.PumpTo(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Copies contents of this stream to the target stream
            </summary>
            <param name="source">The source.</param>
            <param name="target">The target.</param>
            <param name="bufferSize">Size of the buffer.</param>
            <returns>total amount of bytes copied</returns>
        </member>
        <member name="M:Lokad.ExtendStream.PumpTo(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copies contents of this stream to the target stream, using the provided buffer
            </summary>
            <param name="source">The source.</param>
            <param name="target">The target.</param>
            <param name="buffer">The buffer.</param>
            <returns>total amount of bytes copied</returns>
        </member>
        <member name="T:Lokad.SystemUtil">
            <summary>
            System utils to improve testability of the code
            </summary>
        </member>
        <member name="F:Lokad.SystemUtil.SleepAction">
            <summary>
            <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)"/>
            </summary>
        </member>
        <member name="F:Lokad.SystemUtil.DateTimeProvider">
            <summary>
            Allows to set custom date time implementation for the testing purposes.
            </summary>
        </member>
        <member name="M:Lokad.SystemUtil.Reset">
            <summary>
            Returns all overridable functions to default. To be used by test teardowns
            </summary>
        </member>
        <member name="M:Lokad.SystemUtil.SetSleep(System.Action{System.TimeSpan})">
            <summary>
            Sets the custom sleep routine.
            </summary>
            <param name="sleepRoutine">The sleep routine.</param>
        </member>
        <member name="M:Lokad.SystemUtil.SetDateTimeProvider(System.Func{System.DateTime})">
            <summary>
            Sets the custom date time provider routine.
            </summary>
            <param name="dateTimeProvider">The date time provider.</param>
        </member>
        <member name="M:Lokad.SystemUtil.SetTime(System.DateTime)">
            <summary>
            Shortcut to set the custom date time.
            </summary>
            <param name="time">The time.</param>
        </member>
        <member name="M:Lokad.SystemUtil.Sleep(System.TimeSpan)">
            <summary>
            Invokes the method associated with sleeping. For the production purposes
            this should be a call to <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)"/>
            </summary>
            <param name="span">The span.</param>
        </member>
        <member name="P:Lokad.SystemUtil.Now">
            <summary>
            <see cref="P:System.DateTime.Now"/>
            </summary>
        </member>
        <member name="P:Lokad.SystemUtil.UtcNow">
            <summary>
            <see cref="P:System.DateTime.UtcNow"/>
            </summary>
        </member>
        <member name="P:Lokad.SystemUtil.NowOffset">
            <summary>
            Unambiguous date and time with UTC offset, <see cref="P:System.DateTimeOffset.Now"/>.
            </summary>
        </member>
        <member name="T:Lokad.VersionUtil">
            <summary>
            Helper class for <see cref="T:System.Version"/>
            </summary>
        </member>
        <member name="M:Lokad.VersionUtil.Normalize(System.Version)">
            <summary>
            Normalizes the specified version by replacing all -1 with 0
            </summary>
            <param name="version">The version.</param>
            <returns>version that has all 0 replaced with -1</returns>
        </member>
        <member name="T:Lokad.XmlUtil`1">
            <summary>
            Simple static class that caches <see cref="T:System.Xml.Serialization.XmlSerializer"/> instances.
            </summary>
            <typeparam name="TXml"></typeparam>
        </member>
        <member name="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.TextWriter)">
            <summary> Serializes instance to the provided writer </summary>
        </member>
        <member name="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)">
            <summary> Serializes instance to the provided stream </summary>
        </member>
        <member name="M:Lokad.XmlUtil`1.Serialize(`0)">
            <summary>
            Serializes instance to the Xml string
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Lokad.XmlUtil`1.Deserialize(System.String)">
            <summary>
            Helper method for testing - quickly creates object from string
            </summary>
            <param name="source">xml string</param>
            <returns></returns>
        </member>
        <member name="M:Lokad.XmlUtil`1.Deserialize(System.IO.Stream)">
            <summary>
            Helper method to deserialize from the stream using
            the cached serializer.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:Lokad.XmlUtil">
            <summary>
            Helper class for the xml operations
            </summary>
        </member>
        <member name="M:Lokad.XmlUtil.TestXmlSerialization``1(``0)">
            <summary>
            Helper method for testing - checks if the object can be serialized
            </summary>
            <typeparam name="TData">The type of the data.</typeparam>
            <param name="item">The item.</param>
            <returns>deserialized item</returns>
        </member>
        <member name="M:Lokad.XmlUtil.TestXmlSerialization``1">
            <summary>
            Helper method for testing - checks if the class can be serialized
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lokad.XmlUtil.TestXmlSerialization(System.Type)">
            <summary>
            Tests the XML serialization.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Lokad.XmlUtil.Serialize``1(``0,System.IO.TextWriter)">
            <summary>
            <see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Lokad.XmlUtil.SerializeArray``1(``0[],System.IO.TextWriter)">
            <summary>
            	<see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)"/>
            </summary>
            <typeparam name="T">type of the item to serialize</typeparam>
            <param name="stream">The stream.</param>
            <param name="array">The array.</param>
        </member>
        <member name="M:Lokad.XmlUtil.Serialize``1(``0,System.IO.Stream)">
            <summary>
            <see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Lokad.XmlUtil.SerializeArray``1(``0[],System.IO.Stream)">
            <summary>
            	<see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)"/>
            </summary>
            <typeparam name="T">type of the item to serialize</typeparam>
            <param name="stream">The stream.</param>
            <param name="array">The array.</param>
        </member>
        <member name="M:Lokad.XmlUtil.Deserialize``1(System.IO.Stream)">
            <summary>
            <see cref="M:Lokad.XmlUtil`1.Deserialize(System.IO.Stream)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Lokad.XmlUtil.Serialize``1(``0)">
            <summary> Serializes the specified instance. </summary>
            <typeparam name="T">type of the item to serialize</typeparam>
            <param name="instance">The instance.</param>
            <returns>String representation</returns>
        </member>
        <member name="M:Lokad.XmlUtil.SerializeTo``1(``0,System.String)">
            <summary>
            Serializes the specified instance to the specified file
            </summary>
            <typeparam name="TXml">The type of the XML-serializable object.</typeparam>
            <param name="instance">The instance.</param>
            <param name="fileName">Name of the file.</param>
        </member>
        <member name="M:Lokad.XmlUtil.SerializeArray``1(``0[])">
            <summary>
            Serializes the specified instance.
            </summary>
            <typeparam name="T">type of the item to serialize</typeparam>
            <param name="array">The array.</param>
            <returns>String representation</returns>
        </member>
    </members>
</doc>
